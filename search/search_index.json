{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#crewai-documentation","title":"crewAI Documentation","text":"<p>Cutting-edge framework for orchestrating role-playing, autonomous AI agents. By fostering collaborative intelligence, CrewAI empowers agents to work together seamlessly, tackling complex tasks.</p> Core Concepts <ul> <li>                      Agents                  </li> <li>                      Tasks                  </li> <li>                      Tools                  </li> <li>                      Processes                  </li> <li>                      Crews                  </li> <li>                      Memory                  </li> </ul> How-To Guides <ul> <li>                      Installing crewAI                  </li> <li>                      Getting Started                  </li> <li>                      Create Custom Tools                  </li> <li>                      Using Sequential Process                  </li> <li>                      Using Hierarchical Process                  </li> <li>                      Connecting to LLMs                  </li> <li>                      Customizing Agents                  </li> <li>                      Human Input on Execution                  </li> <li>                      Agent Monitoring with AgentOps                  </li> </ul> Examples <ul> <li>                      Prepare for meetings                  </li> <li>                      Trip Planner Crew                  </li> <li>                      Create Instagram Post                  </li> <li>                      Stock Analysis                  </li> <li>                      Game Generator                  </li> <li>                      Drafting emails with LangGraph                  </li> <li>                      Landing Page Generator                  </li> </ul>"},{"location":"core-concepts/Agents/","title":"crewAI Agents","text":""},{"location":"core-concepts/Agents/#what-is-an-agent","title":"What is an Agent?","text":"<p>What is an Agent?</p> <p>An agent is an autonomous unit programmed to: <ul> <li>Perform tasks</li> <li>Make decisions</li> <li>Communicate with other agents</li> </ul>  Think of an agent as a member of a team, with specific skills and a particular job to do. Agents can have different roles like 'Researcher', 'Writer', or 'Customer Support', each contributing to the overall goal of the crew.</p>"},{"location":"core-concepts/Agents/#agent-attributes","title":"Agent Attributes","text":"Attribute Description Role Defines the agent's function within the crew. It determines the kind of tasks the agent is best suited for. Goal The individual objective that the agent aims to achieve. It guides the agent's decision-making process. Backstory Provides context to the agent's role and goal, enriching the interaction and collaboration dynamics. LLM (optional) Represents the language model that will run the agent. It dynamically fetches the model name from the <code>OPENAI_MODEL_NAME</code> environment variable, defaulting to \"gpt-4\" if not specified. Tools (optional) Set of capabilities or functions that the agent can use to perform tasks. Expected to be instances of custom classes compatible with the agent's execution environment. Tools are initialized with a default value of an empty list. Function Calling LLM (optional) Specifies the language model that will handle the tool calling for this agent, overriding the crew function calling LLM if passed. Default is <code>None</code>. Max Iter (optional) The maximum number of iterations the agent can perform before being forced to give its best answer. Default is <code>25</code>. Max RPM (optional) The maximum number of requests per minute the agent can perform to avoid rate limits. It's optional and can be left unspecified, with a default value of <code>None</code>. max_execution_time (optional) Maximum execution time for an agent to execute a task It's optional and can be left unspecified, with a default value of <code>None</code>, menaning no max execution time Verbose (optional) Setting this to <code>True</code> configures the internal logger to provide detailed execution logs, aiding in debugging and monitoring. Default is <code>False</code>. Allow Delegation (optional) Agents can delegate tasks or questions to one another, ensuring that each task is handled by the most suitable agent. Default is <code>True</code>. Step Callback (optional) A function that is called after each step of the agent. This can be used to log the agent's actions or to perform other operations. It will overwrite the crew <code>step_callback</code>. Cache (optional) Indicates if the agent should use a cache for tool usage. Default is <code>True</code>."},{"location":"core-concepts/Agents/#creating-an-agent","title":"Creating an Agent","text":"<p>Agent Interaction</p> <p>Agents can interact with each other using crewAI's built-in delegation and communication mechanisms. This allows for dynamic task management and problem-solving within the crew.</p> <p>To create an agent, you would typically initialize an instance of the <code>Agent</code> class with the desired properties. Here's a conceptual example including all attributes:</p> <pre><code># Example: Creating an agent with all attributes\nfrom crewai import Agent\n\nagent = Agent(\n  role='Data Analyst',\n  goal='Extract actionable insights',\n  backstory=\"\"\"You're a data analyst at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\n  You're currently working on a project to analyze the\n  performance of our marketing campaigns.\"\"\",\n  tools=[my_tool1, my_tool2],  # Optional, defaults to an empty list\n  llm=my_llm,  # Optional\n  function_calling_llm=my_llm,  # Optional\n  max_iter=15,  # Optional\n  max_rpm=None, # Optional\n  verbose=True,  # Optional\n  allow_delegation=True,  # Optional\n  step_callback=my_intermediate_step_callback,  # Optional\n  cache=True  # Optional\n)\n</code></pre>"},{"location":"core-concepts/Agents/#conclusion","title":"Conclusion","text":"<p>Agents are the building blocks of the CrewAI framework. By understanding how to define and interact with agents, you can create sophisticated AI systems that leverage the power of collaborative intelligence.</p>"},{"location":"core-concepts/Collaboration/","title":"How Agents Collaborate in CrewAI","text":""},{"location":"core-concepts/Collaboration/#collaboration-fundamentals","title":"Collaboration Fundamentals","text":"<p>Core of Agent Interaction</p> <p>Collaboration in CrewAI is fundamental, enabling agents to combine their skills, share information, and assist each other in task execution, embodying a truly cooperative ecosystem.</p> <ul> <li>Information Sharing: Ensures all agents are well-informed and can contribute effectively by sharing data and findings.</li> <li>Task Assistance: Allows agents to seek help from peers with the required expertise for specific tasks.</li> <li>Resource Allocation: Optimizes task execution through the efficient distribution and sharing of resources among agents.</li> </ul>"},{"location":"core-concepts/Collaboration/#enhanced-attributes-for-improved-collaboration","title":"Enhanced Attributes for Improved Collaboration","text":"<p>The <code>Crew</code> class has been enriched with several attributes to support advanced functionalities:</p> <ul> <li>Language Model Management (<code>manager_llm</code>, <code>function_calling_llm</code>): Manages language models for executing tasks and tools, facilitating sophisticated agent-tool interactions. Note that while <code>manager_llm</code> is mandatory for hierarchical processes to ensure proper execution flow, <code>function_calling_llm</code> is optional, with a default value provided for streamlined tool interaction.</li> <li>Process Flow (<code>process</code>): Defines the execution logic (e.g., sequential, hierarchical) to streamline task distribution and execution.</li> <li>Verbose Logging (<code>verbose</code>): Offers detailed logging capabilities for monitoring and debugging purposes. It supports both integer and boolean types to indicate the verbosity level. For example, setting <code>verbose</code> to 1 might enable basic logging, whereas setting it to True enables more detailed logs.</li> <li>Rate Limiting (<code>max_rpm</code>): Ensures efficient utilization of resources by limiting requests per minute. Guidelines for setting <code>max_rpm</code> should consider the complexity of tasks and the expected load on resources.</li> <li>Internationalization Support (<code>language</code>, <code>language_file</code>): Facilitates operation in multiple languages, enhancing global usability. Supported languages and the process for utilizing the <code>language_file</code> attribute for customization should be clearly documented.</li> <li>Execution and Output Handling (<code>full_output</code>): Distinguishes between full and final outputs for nuanced control over task results. Examples showcasing the difference in outputs can aid in understanding the practical implications of this attribute.</li> <li>Callback and Telemetry (<code>step_callback</code>, <code>task_callback</code>): Integrates callbacks for step-wise and task-level execution monitoring, alongside telemetry for performance analytics. The purpose and usage of <code>task_callback</code> alongside <code>step_callback</code> for granular monitoring should be clearly explained.</li> <li>Crew Sharing (<code>share_crew</code>): Enables sharing of crew information with CrewAI for continuous improvement and training models. The privacy implications and benefits of this feature, including how it contributes to model improvement, should be outlined.</li> <li>Usage Metrics (<code>usage_metrics</code>): Stores all metrics for the language model (LLM) usage during all tasks' execution, providing insights into operational efficiency and areas for improvement. Detailed information on accessing and interpreting these metrics for performance analysis should be provided.</li> <li>Memory Usage (<code>memory</code>): Indicates whether the crew should use memory to store memories of its execution, enhancing task execution and agent learning.</li> <li>Embedder Configuration (<code>embedder</code>): Specifies the configuration for the embedder to be used by the crew for understanding and generating language. This attribute supports customization of the language model provider.</li> </ul>"},{"location":"core-concepts/Collaboration/#delegation-dividing-to-conquer","title":"Delegation: Dividing to Conquer","text":"<p>Delegation enhances functionality by allowing agents to intelligently assign tasks or seek help, thereby amplifying the crew's overall capability.</p>"},{"location":"core-concepts/Collaboration/#implementing-collaboration-and-delegation","title":"Implementing Collaboration and Delegation","text":"<p>Setting up a crew involves defining the roles and capabilities of each agent. CrewAI seamlessly manages their interactions, ensuring efficient collaboration and delegation, with enhanced customization and monitoring features to adapt to various operational needs.</p>"},{"location":"core-concepts/Collaboration/#example-scenario","title":"Example Scenario","text":"<p>Consider a crew with a researcher agent tasked with data gathering and a writer agent responsible for compiling reports. The integration of advanced language model management and process flow attributes allows for more sophisticated interactions, such as the writer delegating complex research tasks to the researcher or querying specific information, thereby facilitating a seamless workflow.</p>"},{"location":"core-concepts/Collaboration/#conclusion","title":"Conclusion","text":"<p>The integration of advanced attributes and functionalities into the CrewAI framework significantly enriches the agent collaboration ecosystem. These enhancements not only simplify interactions but also offer unprecedented flexibility and control, paving the way for sophisticated AI-driven solutions capable of tackling complex tasks through intelligent collaboration and delegation.</p>"},{"location":"core-concepts/Crews/","title":"crewAI Crews","text":""},{"location":"core-concepts/Crews/#what-is-a-crew","title":"What is a Crew?","text":"<p>A crew in crewAI represents a collaborative group of agents working together to achieve a set of tasks. Each crew defines the strategy for task execution, agent collaboration, and the overall workflow.</p>"},{"location":"core-concepts/Crews/#crew-attributes","title":"Crew Attributes","text":"Attribute Description Tasks A list of tasks assigned to the crew. Agents A list of agents that are part of the crew. Process (optional) The process flow (e.g., sequential, hierarchical) the crew follows. Verbose (optional) The verbosity level for logging during execution. Manager LLM (optional) The language model used by the manager agent in a hierarchical process. Required when using a hierarchical process. Function Calling LLM (optional) If passed, the crew will use this LLM to do function calling for tools for all agents in the crew. Each agent can have its own LLM, which overrides the crew's LLM for function calling. Config (optional) Optional configuration settings for the crew, in <code>Json</code> or <code>Dict[str, Any]</code> format. Max RPM (optional) Maximum requests per minute the crew adheres to during execution. Language (optional) Language used for the crew, defaults to English. Language File (optional) Path to the language file to be used for the crew. Memory (optional) Utilized for storing execution memories (short-term, long-term, entity memory). Cache (optional) Specifies whether to use a cache for storing the results of tools' execution. Embedder (optional) Configuration for the embedder to be used by the crew. mostly used by memory for now Full Output (optional) Whether the crew should return the full output with all tasks outputs or just the final output. Step Callback (optional) A function that is called after each step of every agent. This can be used to log the agent's actions or to perform other operations; it won't override the agent-specific <code>step_callback</code>. Task Callback (optional) A function that is called after the completion of each task. Useful for monitoring or additional operations post-task execution. Share Crew (optional) Whether you want to share the complete crew information and execution with the crewAI team to make the library better, and allow us to train models. Output Log File (optional) Whether you want to have a file with the complete crew output and execution. You can set it using True and it will default to the folder you are currently and it will be called logs.txt or passing a string with the full path and name of the file. <p>Crew Max RPM</p> <p>The <code>max_rpm</code> attribute sets the maximum number of requests per minute the crew can perform to avoid rate limits and will override individual agents' <code>max_rpm</code> settings if you set it.</p>"},{"location":"core-concepts/Crews/#creating-a-crew","title":"Creating a Crew","text":"<p>When assembling a crew, you combine agents with complementary roles and tools, assign tasks, and select a process that dictates their execution order and interaction.</p>"},{"location":"core-concepts/Crews/#example-assembling-a-crew","title":"Example: Assembling a Crew","text":"<pre><code>from crewai import Crew, Agent, Task, Process\nfrom langchain_community.tools import DuckDuckGoSearchRun\n\n# Define agents with specific roles and tools\nresearcher = Agent(\n    role='Senior Research Analyst',\n    goal='Discover innovative AI technologies',\n    tools=[DuckDuckGoSearchRun()]\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Write engaging articles on AI discoveries',\n    verbose=True\n)\n\n# Create tasks for the agents\nresearch_task = Task(\n    description='Identify breakthrough AI technologies',\n    agent=researcher\n)\nwrite_article_task = Task(\n    description='Draft an article on the latest AI technologies',\n    agent=writer\n)\n\n# Assemble the crew with a sequential process\nmy_crew = Crew(\n    agents=[researcher, writer],\n    tasks=[research_task, write_article_task],\n    process=Process.sequential,\n    full_output=True,\n    verbose=True,\n)\n</code></pre>"},{"location":"core-concepts/Crews/#memory-utilization","title":"Memory Utilization","text":"<p>Crews can utilize memory (short-term, long-term, and entity memory) to enhance their execution and learning over time. This feature allows crews to store and recall execution memories, aiding in decision-making and task execution strategies.</p>"},{"location":"core-concepts/Crews/#cache-utilization","title":"Cache Utilization","text":"<p>Caches can be employed to store the results of tools' execution, making the process more efficient by reducing the need to re-execute identical tasks.</p>"},{"location":"core-concepts/Crews/#crew-usage-metrics","title":"Crew Usage Metrics","text":"<p>After the crew execution, you can access the <code>usage_metrics</code> attribute to view the language model (LLM) usage metrics for all tasks executed by the crew. This provides insights into operational efficiency and areas for improvement.</p> <pre><code># Access the crew's usage metrics\ncrew = Crew(agents=[agent1, agent2], tasks=[task1, task2])\ncrew.kickoff()\nprint(crew.usage_metrics)\n</code></pre>"},{"location":"core-concepts/Crews/#crew-execution-process","title":"Crew Execution Process","text":"<ul> <li>Sequential Process: Tasks are executed one after another, allowing for a linear flow of work.</li> <li>Hierarchical Process: A manager agent coordinates the crew, delegating tasks and validating outcomes before proceeding. Note: A <code>manager_llm</code> is required for this process and it's essential for validating the process flow.</li> </ul>"},{"location":"core-concepts/Crews/#kicking-off-a-crew","title":"Kicking Off a Crew","text":"<p>Once your crew is assembled, initiate the workflow with the <code>kickoff()</code> method. This starts the execution process according to the defined process flow.</p> <pre><code># Start the crew's task execution\nresult = my_crew.kickoff()\nprint(result)\n</code></pre>"},{"location":"core-concepts/Memory/","title":"crewAI Memory Systems","text":""},{"location":"core-concepts/Memory/#introduction-to-memory-systems-in-crewai","title":"Introduction to Memory Systems in crewAI","text":"<p>Enhancing Agent Intelligence</p> <p>The crewAI framework introduces a sophisticated memory system designed to significantly enhance the capabilities of AI agents. This system comprises short-term memory, long-term memory, entity memory, and newly identified contextual memory, each serving a unique purpose in aiding agents to remember, reason, and learn from past interactions.</p>"},{"location":"core-concepts/Memory/#memory-system-components","title":"Memory System Components","text":"Component Description Short-Term Memory Temporarily stores recent interactions and outcomes, enabling agents to recall and utilize information relevant to their current context. Long-Term Memory Preserves valuable insights and learnings from past executions, allowing agents to build and refine their knowledge over time. Entity Memory Captures and organizes information about entities (people, places, concepts) encountered during tasks, facilitating deeper understanding and relationship mapping. Contextual Memory Maintains the context of interactions, aiding in the coherence and relevance of agent responses over a sequence of tasks or a conversation."},{"location":"core-concepts/Memory/#how-memory-systems-empower-agents","title":"How Memory Systems Empower Agents","text":"<ol> <li> <p>Contextual Awareness: With short-term and contextual memory, agents gain the ability to maintain context over a conversation or task sequence, leading to more coherent and relevant responses.</p> </li> <li> <p>Experience Accumulation: Long-term memory allows agents to accumulate experiences, learning from past actions to improve future decision-making and problem-solving.</p> </li> <li> <p>Entity Understanding: By maintaining entity memory, agents can recognize and remember key entities, enhancing their ability to process and interact with complex information.</p> </li> </ol>"},{"location":"core-concepts/Memory/#implementing-memory-in-your-crew","title":"Implementing Memory in Your Crew","text":"<p>When configuring a crew, you can enable and customize each memory component to suit the crew's objectives and the nature of tasks it will perform. By default, the memory system is disabled, and you can ensure it is active by setting <code>memory=True</code> in the crew configuration. The memory will use OpenAI Embeddings by default, but you can change it by setting <code>embedder</code> to a different model.</p>"},{"location":"core-concepts/Memory/#example-configuring-memory-for-a-crew","title":"Example: Configuring Memory for a Crew","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\n# Assemble your crew with memory capabilities\nmy_crew = Crew(\n    agents=[...],\n    tasks=[...],\n    process=Process.sequential,\n    memory=True,\n    verbose=True\n)\n</code></pre>"},{"location":"core-concepts/Memory/#additional-embedding-providers","title":"Additional Embedding Providers","text":""},{"location":"core-concepts/Memory/#using-openai-embeddings-already-default","title":"Using OpenAI embeddings (already default)","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n        agents=[...],\n        tasks=[...],\n        process=Process.sequential,\n        memory=True,\n        verbose=True,\n        embedder={\n                \"provider\": \"openai\",\n                \"config\":{\n                        \"model\": 'text-embedding-3-small'\n                }\n        }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-google-ai-embeddings","title":"Using Google AI embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n        agents=[...],\n        tasks=[...],\n        process=Process.sequential,\n        memory=True,\n        verbose=True,\n        embedder={\n            \"provider\": \"google\",\n            \"config\":{\n                \"model\": 'models/embedding-001',\n                \"task_type\": \"retrieval_document\",\n                \"title\": \"Embeddings for Embedchain\"\n            }\n        }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-azure-openai-embeddings","title":"Using Azure OpenAI embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n        agents=[...],\n        tasks=[...],\n        process=Process.sequential,\n        memory=True,\n        verbose=True,\n        embedder={\n            \"provider\": \"azure_openai\",\n            \"config\":{\n                \"model\": 'text-embedding-ada-002',\n                \"deployment_name\": \"you_embedding_model_deployment_name\"\n            }\n        }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-gpt4all-embeddings","title":"Using GPT4ALL embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n        agents=[...],\n        tasks=[...],\n        process=Process.sequential,\n        memory=True,\n        verbose=True,\n        embedder={\n            \"provider\": \"gpt4all\"\n        }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-vertex-ai-embeddings","title":"Using Vertex AI embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n        agents=[...],\n        tasks=[...],\n        process=Process.sequential,\n        memory=True,\n        verbose=True,\n        embedder={\n            \"provider\": \"vertexai\",\n            \"config\":{\n                \"model\": 'textembedding-gecko'\n            }\n        }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#using-cohere-embeddings","title":"Using Cohere embeddings","text":"<pre><code>from crewai import Crew, Agent, Task, Process\n\nmy_crew = Crew(\n        agents=[...],\n        tasks=[...],\n        process=Process.sequential,\n        memory=True,\n        verbose=True,\n        embedder={\n            \"provider\": \"cohere\",\n            \"config\":{\n                \"model\": \"embed-english-v3.0\"\n            \"vector_dimension\": 1024\n            }\n        }\n)\n</code></pre>"},{"location":"core-concepts/Memory/#benefits-of-using-crewais-memory-system","title":"Benefits of Using crewAI's Memory System","text":"<ul> <li>Adaptive Learning: Crews become more efficient over time, adapting to new information and refining their approach to tasks.</li> <li>Enhanced Personalization: Memory enables agents to remember user preferences and historical interactions, leading to personalized experiences.</li> <li>Improved Problem Solving: Access to a rich memory store aids agents in making more informed decisions, drawing on past learnings and contextual insights.</li> </ul>"},{"location":"core-concepts/Memory/#getting-started","title":"Getting Started","text":"<p>Integrating crewAI's memory system into your projects is straightforward. By leveraging the provided memory components and configurations, you can quickly empower your agents with the ability to remember, reason, and learn from their interactions, unlocking new levels of intelligence and capability.</p>"},{"location":"core-concepts/Processes/","title":"Managing Processes in CrewAI","text":""},{"location":"core-concepts/Processes/#understanding-processes","title":"Understanding Processes","text":"<p>Core Concept</p> <p>In CrewAI, processes orchestrate the execution of tasks by agents, akin to project management in human teams. These processes ensure tasks are distributed and executed efficiently, in alignment with a predefined strategy.</p>"},{"location":"core-concepts/Processes/#process-implementations","title":"Process Implementations","text":"<ul> <li>Sequential: Executes tasks sequentially, ensuring tasks are completed in an orderly progression.</li> <li>Hierarchical: Organizes tasks in a managerial hierarchy, where tasks are delegated and executed based on a structured chain of command. A manager language model (<code>manager_llm</code>) must be specified in the crew to enable the hierarchical process, facilitating the creation and management of tasks by the manager.</li> <li>Consensual Process (Planned): Aiming for collaborative decision-making among agents on task execution, this process type introduces a democratic approach to task management within CrewAI. It is planned for future development and is not currently implemented in the codebase.</li> </ul>"},{"location":"core-concepts/Processes/#the-role-of-processes-in-teamwork","title":"The Role of Processes in Teamwork","text":"<p>Processes enable individual agents to operate as a cohesive unit, streamlining their efforts to achieve common objectives with efficiency and coherence.</p>"},{"location":"core-concepts/Processes/#assigning-processes-to-a-crew","title":"Assigning Processes to a Crew","text":"<p>To assign a process to a crew, specify the process type upon crew creation to set the execution strategy. For a hierarchical process, ensure to define <code>manager_llm</code> for the manager agent.</p> <p><pre><code>from crewai import Crew\nfrom crewai.process import Process\nfrom langchain_openai import ChatOpenAI\n\n# Example: Creating a crew with a sequential process\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.sequential\n)\n\n# Example: Creating a crew with a hierarchical process\n# Ensure to provide a manager_llm\ncrew = Crew(\n    agents=my_agents,\n    tasks=my_tasks,\n    process=Process.hierarchical,\n    manager_llm=ChatOpenAI(model=\"gpt-4\")\n)\n</code></pre> Note: Ensure <code>my_agents</code> and <code>my_tasks</code> are defined prior to creating a <code>Crew</code> object, and for the hierarchical process, <code>manager_llm</code> is also required.</p>"},{"location":"core-concepts/Processes/#sequential-process","title":"Sequential Process","text":"<p>This method mirrors dynamic team workflows, progressing through tasks in a thoughtful and systematic manner. Task execution follows the predefined order in the task list, with the output of one task serving as context for the next.</p> <p>To customize task context, utilize the <code>context</code> parameter in the <code>Task</code> class to specify outputs that should be used as context for subsequent tasks.</p>"},{"location":"core-concepts/Processes/#hierarchical-process","title":"Hierarchical Process","text":"<p>Emulates a corporate hierarchy, CrewAI automatically creates a manager for you, requiring the specification of a manager language model (<code>manager_llm</code>) for the manager agent. This agent oversees task execution, including planning, delegation, and validation. Tasks are not pre-assigned; the manager allocates tasks to agents based on their capabilities, reviews outputs, and assesses task completion.</p>"},{"location":"core-concepts/Processes/#process-class-detailed-overview","title":"Process Class: Detailed Overview","text":"<p>The <code>Process</code> class is implemented as an enumeration (<code>Enum</code>), ensuring type safety and restricting process values to the defined types (<code>sequential</code>, <code>hierarchical</code>). The consensual process is planned for future inclusion, emphasizing our commitment to continuous development and innovation.</p>"},{"location":"core-concepts/Processes/#additional-task-features","title":"Additional Task Features","text":"<ul> <li>Asynchronous Execution: Tasks can now be executed asynchronously, allowing for parallel processing and efficiency improvements. This feature is designed to enable tasks to be carried out concurrently, enhancing the overall productivity of the crew.</li> <li>Human Input Review: An optional feature that enables the review of task outputs by humans to ensure quality and accuracy before finalization. This additional step introduces a layer of oversight, providing an opportunity for human intervention and validation.</li> <li>Output Customization: Tasks support various output formats, including JSON (<code>output_json</code>), Pydantic models (<code>output_pydantic</code>), and file outputs (<code>output_file</code>), providing flexibility in how task results are captured and utilized. This allows for a wide range of output possibilities, catering to different needs and requirements.</li> </ul>"},{"location":"core-concepts/Processes/#conclusion","title":"Conclusion","text":"<p>The structured collaboration facilitated by processes within CrewAI is crucial for enabling systematic teamwork among agents. This documentation has been updated to reflect the latest features, enhancements, and the planned integration of the Consensual Process, ensuring users have access to the most current and comprehensive information.</p>"},{"location":"core-concepts/Tasks/","title":"crewAI Tasks","text":""},{"location":"core-concepts/Tasks/#overview-of-a-task","title":"Overview of a Task","text":"<p>What is a Task?</p> <p>In the crewAI framework, tasks are specific assignments completed by agents. They provide all necessary details for execution, such as a description, the agent responsible, required tools, and more, facilitating a wide range of action complexities.</p> <p>Tasks within crewAI can be collaborative, requiring multiple agents to work together. This is managed through the task properties and orchestrated by the Crew's process, enhancing teamwork and efficiency.</p>"},{"location":"core-concepts/Tasks/#task-attributes","title":"Task Attributes","text":"Attribute Description Description A clear, concise statement of what the task entails. Agent The agent responsible for the task, assigned either directly or by the crew's process. Expected Output A detailed description of what the task's completion looks like. Tools (optional) The functions or capabilities the agent can utilize to perform the task. Async Execution (optional) If set, the task executes asynchronously, allowing progression without waiting for completion. Context (optional) Specifies tasks whose outputs are used as context for this task. Config (optional) Additional configuration details for the agent executing the task, allowing further customization. Output JSON (optional) Outputs a JSON object, requiring an OpenAI client. Only one output format can be set. Output Pydantic (optional) Outputs a Pydantic model object, requiring an OpenAI client. Only one output format can be set. Output File (optional) Saves the task output to a file. If used with <code>Output JSON</code> or <code>Output Pydantic</code>, specifies how the output is saved. Callback (optional) A Python callable that is executed with the task's output upon completion. Human Input (optional) Indicates if the task requires human feedback at the end, useful for tasks needing human oversight."},{"location":"core-concepts/Tasks/#creating-a-task","title":"Creating a Task","text":"<p>Creating a task involves defining its scope, responsible agent, and any additional attributes for flexibility:</p> <pre><code>from crewai import Task\n\ntask = Task(\n    description='Find and summarize the latest and most relevant news on AI',\n    agent=sales_agent\n)\n</code></pre> <p>Task Assignment</p> <p>Directly specify an <code>agent</code> for assignment or let the <code>hierarchical</code> CrewAI's process decide based on roles, availability, etc.</p>"},{"location":"core-concepts/Tasks/#integrating-tools-with-tasks","title":"Integrating Tools with Tasks","text":"<p>Leverage tools from the crewAI Toolkit and LangChain Tools for enhanced task performance and agent interaction.</p>"},{"location":"core-concepts/Tasks/#creating-a-task-with-tools","title":"Creating a Task with Tools","text":"<pre><code>import os\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\n\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nresearch_agent = Agent(\n  role='Researcher',\n  goal='Find and summarize the latest AI news',\n  backstory=\"\"\"You're a researcher at a large company.\n  You're responsible for analyzing data and providing insights\n  to the business.\"\"\",\n  verbose=True\n)\n\nsearch_tool = SerperDevTool()\n\ntask = Task(\n  description='Find and summarize the latest AI news',\n  expected_output='A bullet list summary of the top 5 most important AI news',\n  agent=research_agent,\n  tools=[search_tool]\n)\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task],\n    verbose=2\n)\n\nresult = crew.kickoff()\nprint(result)\n</code></pre> <p>This demonstrates how tasks with specific tools can override an agent's default set for tailored task execution.</p>"},{"location":"core-concepts/Tasks/#referring-to-other-tasks","title":"Referring to Other Tasks","text":"<p>In crewAI, the output of one task is automatically relayed into the next one, but you can specifically define what tasks' output, including multiple should be used as context for another task.</p> <p>This is useful when you have a task that depends on the output of another task that is not performed immediately after it. This is done through the <code>context</code> attribute of the task:</p> <pre><code># ...\n\nresearch_ai_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nresearch_ops_task = Task(\n    description='Find and summarize the latest AI Ops news',\n    expected_output='A bullet list summary of the top 5 most important AI Ops news',\n    async_execution=True,\n    agent=research_agent,\n    tools=[search_tool]\n)\n\nwrite_blog_task = Task(\n    description=\"Write a full blog post about the importance of AI and its latest news\",\n    expected_output='Full blog post that is 4 paragraphs long',\n    agent=writer_agent,\n    context=[research_ai_task, research_ops_task]\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#asynchronous-execution","title":"Asynchronous Execution","text":"<p>You can define a task to be executed asynchronously. This means that the crew will not wait for it to be completed to continue with the next task. This is useful for tasks that take a long time to be completed, or that are not crucial for the next tasks to be performed.</p> <p>You can then use the <code>context</code> attribute to define in a future task that it should wait for the output of the asynchronous task to be completed.</p> <pre><code>#...\n\nlist_ideas = Task(\n    description=\"List of 5 interesting ideas to explore for an article about AI.\",\n    expected_output=\"Bullet point list of 5 ideas for an article.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nlist_important_history = Task(\n    description=\"Research the history of AI and give me the 5 most important events.\",\n    expected_output=\"Bullet point list of 5 important events.\",\n    agent=researcher,\n    async_execution=True # Will be executed asynchronously\n)\n\nwrite_article = Task(\n    description=\"Write an article about AI, its history, and interesting ideas.\",\n    expected_output=\"A 4 paragraph article about AI.\",\n    agent=writer,\n    context=[list_ideas, list_important_history] # Will wait for the output of the two tasks to be completed\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#callback-mechanism","title":"Callback Mechanism","text":"<p>The callback function is executed after the task is completed, allowing for actions or notifications to be triggered based on the task's outcome.</p> <pre><code># ...\n\ndef callback_function(output: TaskOutput):\n    # Do something after the task is completed\n    # Example: Send an email to the manager\n    print(f\"\"\"\n        Task completed!\n        Task: {output.description}\n        Output: {output.raw_output}\n    \"\"\")\n\nresearch_task = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool],\n    callback=callback_function\n)\n\n#...\n</code></pre>"},{"location":"core-concepts/Tasks/#accessing-a-specific-task-output","title":"Accessing a Specific Task Output","text":"<p>Once a crew finishes running, you can access the output of a specific task by using the <code>output</code> attribute of the task object:</p> <pre><code># ...\ntask1 = Task(\n    description='Find and summarize the latest AI news',\n    expected_output='A bullet list summary of the top 5 most important AI news',\n    agent=research_agent,\n    tools=[search_tool]\n)\n\n#...\n\ncrew = Crew(\n    agents=[research_agent],\n    tasks=[task1, task2, task3],\n    verbose=2\n)\n\nresult = crew.kickoff()\n\n# Returns a TaskOutput object with the description and results of the task\nprint(f\"\"\"\n    Task completed!\n    Task: {task1.output.description}\n    Output: {task1.output.raw_output}\n\"\"\")\n</code></pre>"},{"location":"core-concepts/Tasks/#tool-override-mechanism","title":"Tool Override Mechanism","text":"<p>Specifying tools in a task allows for dynamic adaptation of agent capabilities, emphasizing CrewAI's flexibility.</p>"},{"location":"core-concepts/Tasks/#error-handling-and-validation-mechanisms","title":"Error Handling and Validation Mechanisms","text":"<p>While creating and executing tasks, certain validation mechanisms are in place to ensure the robustness and reliability of task attributes. These include but are not limited to:</p> <ul> <li>Ensuring only one output type is set per task to maintain clear output expectations.</li> <li>Preventing the manual assignment of the <code>id</code> attribute to uphold the integrity of the unique identifier system.</li> </ul> <p>These validations help in maintaining the consistency and reliability of task executions within the crewAI framework.</p>"},{"location":"core-concepts/Tasks/#conclusion","title":"Conclusion","text":"<p>Tasks are the driving force behind the actions of agents in crewAI. By properly defining tasks and their outcomes, you set the stage for your AI agents to work effectively, either independently or as a collaborative unit. Equipping tasks with appropriate tools, understanding the execution process, and following robust validation practices are crucial for maximizing CrewAI's potential, ensuring agents are effectively prepared for their assignments and that tasks are executed as intended.</p>"},{"location":"core-concepts/Tools/","title":"crewAI Tools","text":""},{"location":"core-concepts/Tools/#introduction","title":"Introduction","text":"<p>CrewAI tools empower agents with capabilities ranging from web searching and data analysis to collaboration and delegating tasks among coworkers. This documentation outlines how to create, integrate, and leverage these tools within the CrewAI framework, including a new focus on collaboration tools.</p>"},{"location":"core-concepts/Tools/#what-is-a-tool","title":"What is a Tool?","text":"<p>Definition</p> <p>A tool in CrewAI is a skill or function that agents can utilize to perform various actions. This includes tools from the crewAI Toolkit and LangChain Tools, enabling everything from simple searches to complex interactions and effective teamwork among agents.</p>"},{"location":"core-concepts/Tools/#key-characteristics-of-tools","title":"Key Characteristics of Tools","text":"<ul> <li>Utility: Crafted for tasks such as web searching, data analysis, content generation, and agent collaboration.</li> <li>Integration: Boosts agent capabilities by seamlessly integrating tools into their workflow.</li> <li>Customizability: Provides the flexibility to develop custom tools or utilize existing ones, catering to the specific needs of agents.</li> <li>Error Handling: Incorporates robust error handling mechanisms to ensure smooth operation.</li> <li>Caching Mechanism: Features intelligent caching to optimize performance and reduce redundant operations.</li> </ul>"},{"location":"core-concepts/Tools/#using-crewai-tools","title":"Using crewAI Tools","text":"<p>To enhance your agents' capabilities with crewAI tools, begin by installing our extra tools package:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>Here's an example demonstrating their use:</p> <pre><code>import os\nfrom crewai import Agent, Task, Crew\n# Importing crewAI tools\nfrom crewai_tools import (\n    DirectoryReadTool,\n    FileReadTool,\n    SerperDevTool,\n    WebsiteSearchTool\n)\n\n# Set up API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Instantiate tools\ndocs_tool = DirectoryReadTool(directory='./blog-posts')\nfile_tool = FileReadTool()\nsearch_tool = SerperDevTool()\nweb_rag_tool = WebsiteSearchTool()\n\n# Create agents\nresearcher = Agent(\n    role='Market Research Analyst',\n    goal='Provide up-to-date market analysis of the AI industry',\n    backstory='An expert analyst with a keen eye for market trends.',\n    tools=[search_tool, web_rag_tool],\n    verbose=True\n)\n\nwriter = Agent(\n    role='Content Writer',\n    goal='Craft engaging blog posts about the AI industry',\n    backstory='A skilled writer with a passion for technology.',\n    tools=[docs_tool, file_tool],\n    verbose=True\n)\n\n# Define tasks\nresearch = Task(\n    description='Research the latest trends in the AI industry and provide a summary.',\n    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',\n    agent=researcher\n)\n\nwrite = Task(\n    description='Write an engaging blog post about the AI industry, based on the research analyst\u2019s summary. Draw inspiration from the latest blog posts in the directory.',\n    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',\n    agent=writer,\n    output_file='blog-posts/new_post.md'  # The final blog post will be saved here\n)\n\n# Assemble a crew\ncrew = Crew(\n    agents=[researcher, writer],\n    tasks=[research, write],\n    verbose=2\n)\n\n# Execute tasks\ncrew.kickoff()\n</code></pre>"},{"location":"core-concepts/Tools/#available-crewai-tools","title":"Available crewAI Tools","text":"<ul> <li>Error Handling: All tools are built with error handling capabilities, allowing agents to gracefully manage exceptions and continue their tasks.</li> <li>Caching Mechanism: All tools support caching, enabling agents to efficiently reuse previously obtained results, reducing the load on external resources and speeding up the execution time, you can also define finner control over the caching mechanism, using <code>cache_function</code> attribute on the tool.</li> </ul> <p>Here is a list of the available tools and their descriptions:</p> Tool Description CodeDocsSearchTool A RAG tool optimized for searching through code documentation and related technical documents. CSVSearchTool A RAG tool designed for searching within CSV files, tailored to handle structured data. DirectorySearchTool A RAG tool for searching within directories, useful for navigating through file systems. DOCXSearchTool A RAG tool aimed at searching within DOCX documents, ideal for processing Word files. DirectoryReadTool Facilitates reading and processing of directory structures and their contents. FileReadTool Enables reading and extracting data from files, supporting various file formats. GithubSearchTool A RAG tool for searching within GitHub repositories, useful for code and documentation search. SerperDevTool A specialized tool for development purposes, with specific functionalities under development. TXTSearchTool A RAG tool focused on searching within text (.txt) files, suitable for unstructured data. JSONSearchTool A RAG tool designed for searching within JSON files, catering to structured data handling. MDXSearchTool A RAG tool tailored for searching within Markdown (MDX) files, useful for documentation. PDFSearchTool A RAG tool aimed at searching within PDF documents, ideal for processing scanned documents. PGSearchTool A RAG tool optimized for searching within PostgreSQL databases, suitable for database queries. RagTool A general-purpose RAG tool capable of handling various data sources and types. ScrapeElementFromWebsiteTool Enables scraping specific elements from websites, useful for targeted data extraction. ScrapeWebsiteTool Facilitates scraping entire websites, ideal for comprehensive data collection. WebsiteSearchTool A RAG tool for searching website content, optimized for web data extraction. XMLSearchTool A RAG tool designed for searching within XML files, suitable for structured data formats. YoutubeChannelSearchTool A RAG tool for searching within YouTube channels, useful for video content analysis. YoutubeVideoSearchTool A RAG tool aimed at searching within YouTube videos, ideal for video data extraction."},{"location":"core-concepts/Tools/#creating-your-own-tools","title":"Creating your own Tools","text":"<p>Custom Tool Creation</p> <p>Developers can craft custom tools tailored for their agent\u2019s needs or utilize pre-built options:</p> <p>To create your own crewAI tools you will need to install our extra tools package:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>Once you do that there are two main ways for one to create a crewAI tool:</p>"},{"location":"core-concepts/Tools/#subclassing-basetool","title":"Subclassing <code>BaseTool</code>","text":"<pre><code>from crewai_tools import BaseTool\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"Clear description for what this tool is useful for, you agent will need this information to use it.\"\n\n    def _run(self, argument: str) -&gt; str:\n        # Implementation goes here\n        return \"Result from custom tool\"\n</code></pre>"},{"location":"core-concepts/Tools/#utilizing-the-tool-decorator","title":"Utilizing the <code>tool</code> Decorator","text":"<pre><code>from crewai_tools import tool\n@tool(\"Name of my tool\")\ndef my_tool(question: str) -&gt; str:\n    \"\"\"Clear description for what this tool is useful for, you agent will need this information to use it.\"\"\"\n    # Function logic here\n    return \"Result from your custom tool\"\n</code></pre>"},{"location":"core-concepts/Tools/#custom-caching-mechanism","title":"Custom Caching Mechanism","text":"<p>Caching</p> <p>Tools can optionally implement a <code>cache_function</code> to fine-tune caching behavior. This function determines when to cache results based on specific conditions, offering granular control over caching logic.</p> <pre><code>from crewai_tools import tool\n\n@tool\ndef multiplication_tool(first_number: int, second_number: int) -&gt; str:\n    \"\"\"Useful for when you need to multiply two numbers together.\"\"\"\n    return first_number * second_number\n\ndef cache_func(args, result):\n    # In this case, we only cache the result if it's a multiple of 2\n    cache = result % 2 == 0\n    return cache\n\nmultiplication_tool.cache_function = cache_func\n\nwriter1 = Agent(\n        role=\"Writer\",\n        goal=\"You write lesssons of math for kids.\",\n        backstory=\"You're an expert in writting and you love to teach kids but you know nothing of math.\",\n        tools=[multiplcation_tool],\n        allow_delegation=False,\n    )\n    #...\n</code></pre>"},{"location":"core-concepts/Tools/#using-langchain-tools","title":"Using LangChain Tools","text":"<p>LangChain Integration</p> <p>CrewAI seamlessly integrates with LangChain\u2019s comprehensive toolkit for search-based queries and more, here are the available built-in tools that are offered by Langchain LangChain Toolkit</p> <p>:</p> <pre><code>from crewai import Agent\nfrom langchain.agents import Tool\nfrom langchain.utilities import GoogleSerperAPIWrapper\n\n# Setup API keys\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\nsearch = GoogleSerperAPIWrapper()\n\n# Create and assign the search tool to an agent\nserper_tool = Tool(\n  name=\"Intermediate Answer\",\n  func=search.run,\n  description=\"Useful for search-based queries\",\n)\n\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[serper_tool]\n)\n\n# rest of the code ...\n</code></pre>"},{"location":"core-concepts/Tools/#conclusion","title":"Conclusion","text":"<p>Tools are pivotal in extending the capabilities of CrewAI agents, enabling them to undertake a broad spectrum of tasks and collaborate effectively. When building solutions with CrewAI, leverage both custom and existing tools to empower your agents and enhance the AI ecosystem. Consider utilizing error handling, caching mechanisms, and the flexibility of tool arguments to optimize your agents' performance and capabilities.</p>"},{"location":"how-to/AgentOps-Observability/","title":"Intro","text":"<p>Observability is a key aspect of developing and deploying conversational AI agents. It allows developers to understand how their agents are performing, how their agents are interacting with users, and how their agents use external tools and APIs. AgentOps is a product independent of CrewAI that provides a comprehensive observability solution for agents. </p>"},{"location":"how-to/AgentOps-Observability/#agentops","title":"AgentOps","text":"<p>AgentOps provides session replays, metrics, and monitoring for agents.</p> <p>At a high level, AgentOps gives you the ability to monitor cost, token usage, latency, agent failures, session-wide statistics, and more. For more info, check out the AgentOps Repo.</p>"},{"location":"how-to/AgentOps-Observability/#overview","title":"Overview","text":"<p>AgentOps provides monitoring for agents in development and production. It provides a dashboard for tracking agent performance, session replays, and custom reporting.</p> <p>Additionally, AgentOps provides session drilldowns for viewing Crew agent interactions, LLM calls, and tool usage in real-time. This feature is useful for debugging and understanding how agents interact with users as well as other agents.</p> <p> </p>"},{"location":"how-to/AgentOps-Observability/#features","title":"Features","text":"<ul> <li>LLM Cost Management and Tracking: Track spend with foundation model providers</li> <li>Replay Analytics: Watch step-by-step agent execution graphs</li> <li>Recursive Thought Detection: Identify when agents fall into infinite loops</li> <li>Custom Reporting: Create custom analytics on agent performance</li> <li>Analytics Dashboard: Monitor high level statistics about agents in development and production</li> <li>Public Model Testing: Test your agents against benchmarks and leaderboards</li> <li>Custom Tests: Run your agents against domain specific tests</li> <li>Time Travel Debugging: Restart your sessions from checkpoints</li> <li>Compliance and Security: Create audit logs and detect potential threats such as profanity and PII leaks</li> <li>Prompt Injection Detection: Identify potential code injection and secret leaks</li> </ul>"},{"location":"how-to/AgentOps-Observability/#using-agentops","title":"Using AgentOps","text":"<ol> <li> <p>Create an API Key: Create a user API key here: Create API Key</p> </li> <li> <p>Configure Your Environment: Add your API key to your environment variables</p> </li> </ol> <pre><code>AGENTOPS_API_KEY=&lt;YOUR_AGENTOPS_API_KEY&gt;\n</code></pre> <ol> <li>Install AgentOps: Install AgentOps with: <pre><code>pip install crewai[agentops]\n</code></pre> or <pre><code>pip install agentops\n</code></pre></li> </ol> <p>Before using <code>Crew</code> in your script, include these lines:</p> <pre><code>import agentops\nagentops.init()\n</code></pre> <p>This will initiate an AgentOps session as well as automatically track Crew agents. For further info on how to outfit more complex agentic systems, check out the AgentOps documentation or join the Discord.</p>"},{"location":"how-to/AgentOps-Observability/#crew-agentops-examples","title":"Crew + AgentOps Examples","text":"<ul> <li>Job Posting</li> <li>Markdown Validator</li> <li>Instagram Post</li> </ul>"},{"location":"how-to/AgentOps-Observability/#further-information","title":"Further Information","text":"<p>To get started, create an AgentOps account.</p> <p>For feature requests or bug reports, please reach out to the AgentOps team on the AgentOps Repo.</p>"},{"location":"how-to/AgentOps-Observability/#extra-links","title":"Extra links","text":"<p>\ud83d\udc26 Twitter \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udce2 Discord \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udd87\ufe0f AgentOps Dashboard \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udcd9 Documentation</p>"},{"location":"how-to/Create-Custom-Tools/","title":"Creating and Utilizing Tools in crewAI","text":""},{"location":"how-to/Create-Custom-Tools/#creating-and-utilizing-tools-in-crewai","title":"Creating and Utilizing Tools in crewAI","text":"<p>This guide provides detailed instructions on creating custom tools for the crewAI framework and how to efficiently manage and utilize these tools, incorporating the latest functionalities such as tool delegation, error handling, and dynamic tool calling. It also highlights the importance of collaboration tools, enabling agents to perform a wide range of actions.</p>"},{"location":"how-to/Create-Custom-Tools/#prerequisites","title":"Prerequisites","text":"<p>Before creating your own tools, ensure you have the crewAI extra tools package installed:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/#subclassing-basetool","title":"Subclassing <code>BaseTool</code>","text":"<p>To create a personalized tool, inherit from <code>BaseTool</code> and define the necessary attributes and the <code>_run</code> method.</p> <pre><code>from crewai_tools import BaseTool\n\nclass MyCustomTool(BaseTool):\n    name: str = \"Name of my tool\"\n    description: str = \"What this tool does. It's vital for effective utilization.\"\n\n    def _run(self, argument: str) -&gt; str:\n        # Your tool's logic here\n        return \"Tool's result\"\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/#using-the-tool-decorator","title":"Using the <code>tool</code> Decorator","text":"<p>Alternatively, use the <code>tool</code> decorator for a direct approach to create tools. This requires specifying attributes and the tool's logic within a function.</p> <pre><code>from crewai_tools import tool\n\n@tool(\"Tool Name\")\ndef my_simple_tool(question: str) -&gt; str:\n    \"\"\"Tool description for clarity.\"\"\"\n    # Tool logic here\n    return \"Tool output\"\n</code></pre>"},{"location":"how-to/Create-Custom-Tools/#defining-a-cache-function-for-the-tool","title":"Defining a Cache Function for the Tool","text":"<p>To optimize tool performance with caching, define custom caching strategies using the <code>cache_function</code> attribute.</p> <pre><code>@tool(\"Tool with Caching\")\ndef cached_tool(argument: str) -&gt; str:\n    \"\"\"Tool functionality description.\"\"\"\n    return \"Cachable result\"\n\ndef my_cache_strategy(arguments: dict, result: str) -&gt; bool:\n    # Define custom caching logic\n    return True if some_condition else False\n\ncached_tool.cache_function = my_cache_strategy\n</code></pre> <p>By adhering to these guidelines and incorporating new functionalities and collaboration tools into your tool creation and management processes, you can leverage the full capabilities of the crewAI framework, enhancing both the development experience and the efficiency of your AI agents.</p>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/","title":"Assembling and Activating Your CrewAI Team","text":""},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#introduction","title":"Introduction","text":"<p>Embark on your CrewAI journey by setting up your environment and initiating your AI crew with the latest features. This guide ensures a smooth start, incorporating all recent updates for an enhanced experience.</p>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#step-0-installation","title":"Step 0: Installation","text":"<p>Install CrewAI and any necessary packages for your project. CrewAI is compatible with Python &gt;=3.10,&lt;=3.13.</p> <pre><code>pip install crewai\npip install 'crewai[tools]'\n</code></pre>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#step-1-assemble-your-agents","title":"Step 1: Assemble Your Agents","text":"<p>Define your agents with distinct roles, backstories, and enhanced capabilities like verbose mode and memory usage. These elements add depth and guide their task execution and interaction within the crew.</p> <pre><code>import os\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"  # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\nsearch_tool = SerperDevTool()\n\n# Creating a senior researcher agent with memory and verbose mode\nresearcher = Agent(\n  role='Senior Researcher',\n  goal='Uncover groundbreaking technologies in {topic}',\n  verbose=True,\n  memory=True,\n  backstory=(\n    \"Driven by curiosity, you're at the forefront of\"\n    \"innovation, eager to explore and share knowledge that could change\"\n    \"the world.\"\n  ),\n  tools=[search_tool],\n  allow_delegation=True\n)\n\n# Creating a writer agent with custom tools and delegation capability\nwriter = Agent(\n  role='Writer',\n  goal='Narrate compelling tech stories about {topic}',\n  verbose=True,\n  memory=True,\n  backstory=(\n    \"With a flair for simplifying complex topics, you craft\"\n    \"engaging narratives that captivate and educate, bringing new\"\n    \"discoveries to light in an accessible manner.\"\n  ),\n  tools=[search_tool],\n  allow_delegation=False\n)\n</code></pre>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#step-2-define-the-tasks","title":"Step 2: Define the Tasks","text":"<p>Detail the specific objectives for your agents, including new features for asynchronous execution and output customization. These tasks ensure a targeted approach to their roles.</p> <pre><code>from crewai import Task\n\n# Research task\nresearch_task = Task(\n  description=(\n    \"Identify the next big trend in {topic}.\"\n    \"Focus on identifying pros and cons and the overall narrative.\"\n    \"Your final report should clearly articulate the key points,\"\n    \"its market opportunities, and potential risks.\"\n  ),\n  expected_output='A comprehensive 3 paragraphs long report on the latest AI trends.',\n  tools=[search_tool],\n  agent=researcher,\n)\n\n# Writing task with language model configuration\nwrite_task = Task(\n  description=(\n    \"Compose an insightful article on {topic}.\"\n    \"Focus on the latest trends and how it's impacting the industry.\"\n    \"This article should be easy to understand, engaging, and positive.\"\n  ),\n  expected_output='A 4 paragraph article on {topic} advancements formatted as markdown.',\n  tools=[search_tool],\n  agent=writer,\n  async_execution=False,\n  output_file='new-blog-post.md'  # Example of output customization\n)\n</code></pre>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#step-3-form-the-crew","title":"Step 3: Form the Crew","text":"<p>Combine your agents into a crew, setting the workflow process they'll follow to accomplish the tasks. Now with options to configure language models for enhanced interaction and additional configurations for optimizing performance.</p> <pre><code>from crewai import Crew, Process\n\n# Forming the tech-focused crew with some enhanced configurations\ncrew = Crew(\n  agents=[researcher, writer],\n  tasks=[research_task, write_task],\n  process=Process.sequential,  # Optional: Sequential task execution is default\n  memory=True,\n  cache=True,\n  max_rpm=100,\n  share_crew=True\n)\n</code></pre>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#step-4-kick-it-off","title":"Step 4: Kick It Off","text":"<p>Initiate the process with your enhanced crew ready. Observe as your agents collaborate, leveraging their new capabilities for a successful project outcome. Input variables will be interpolated into the agents and tasks for a personalized approach.</p> <pre><code># Starting the task execution process with enhanced feedback\nresult = crew.kickoff(inputs={'topic': 'AI in healthcare'})\nprint(result)\n</code></pre>"},{"location":"how-to/Creating-a-Crew-and-kick-it-off/#conclusion","title":"Conclusion","text":"<p>Building and activating a crew in CrewAI has evolved with new functionalities. By incorporating verbose mode, memory capabilities, asynchronous task execution, output customization, language model configuration, and enhanced crew configurations, your AI team is more equipped than ever to tackle challenges efficiently. The depth of agent backstories and the precision of their objectives enrich collaboration, leading to successful project outcomes. This guide aims to provide you with a clear and detailed understanding of setting up and utilizing the CrewAI framework to its full potential.</p>"},{"location":"how-to/Customizing-Agents/","title":"Customizing Agents in CrewAI","text":""},{"location":"how-to/Customizing-Agents/#customizable-attributes","title":"Customizable Attributes","text":"<p>Crafting an efficient CrewAI team hinges on the ability to dynamically tailor your AI agents to meet the unique requirements of any project. This section covers the foundational attributes you can customize.</p>"},{"location":"how-to/Customizing-Agents/#key-attributes-for-customization","title":"Key Attributes for Customization","text":"<ul> <li>Role: Specifies the agent's job within the crew, such as 'Analyst' or 'Customer Service Rep'.</li> <li>Goal: Defines what the agent aims to achieve, in alignment with its role and the overarching objectives of the crew.</li> <li>Backstory: Provides depth to the agent's persona, enriching its motivations and engagements within the crew.</li> <li>Tools: Represents the capabilities or methods the agent uses to perform tasks, from simple functions to intricate integrations.</li> </ul>"},{"location":"how-to/Customizing-Agents/#advanced-customization-options","title":"Advanced Customization Options","text":"<p>Beyond the basic attributes, CrewAI allows for deeper customization to enhance an agent's behavior and capabilities significantly.</p>"},{"location":"how-to/Customizing-Agents/#language-model-customization","title":"Language Model Customization","text":"<p>Agents can be customized with specific language models (<code>llm</code>) and function-calling language models (<code>function_calling_llm</code>), offering advanced control over their processing and decision-making abilities. It's important to note that setting the <code>function_calling_llm</code> allows for overriding the default crew function-calling language model, providing a greater degree of customization.</p>"},{"location":"how-to/Customizing-Agents/#performance-and-debugging-settings","title":"Performance and Debugging Settings","text":"<p>Adjusting an agent's performance and monitoring its operations are crucial for efficient task execution.</p>"},{"location":"how-to/Customizing-Agents/#verbose-mode-and-rpm-limit","title":"Verbose Mode and RPM Limit","text":"<ul> <li>Verbose Mode: Enables detailed logging of an agent's actions, useful for debugging and optimization. Specifically, it provides insights into agent execution processes, aiding in the optimization of performance.</li> <li>RPM Limit: Sets the maximum number of requests per minute (<code>max_rpm</code>). This attribute is optional and can be set to <code>None</code> for no limit, allowing for unlimited queries to external services if needed.</li> </ul>"},{"location":"how-to/Customizing-Agents/#maximum-iterations-for-task-execution","title":"Maximum Iterations for Task Execution","text":"<p>The <code>max_iter</code> attribute allows users to define the maximum number of iterations an agent can perform for a single task, preventing infinite loops or excessively long executions. The default value is set to 15, providing a balance between thoroughness and efficiency. Once the agent approaches this number, it will try its best to give a good answer.</p>"},{"location":"how-to/Customizing-Agents/#customizing-agents-and-tools","title":"Customizing Agents and Tools","text":"<p>Agents are customized by defining their attributes and tools during initialization. Tools are critical for an agent's functionality, enabling them to perform specialized tasks. The <code>tools</code> attribute should be an array of tools the agent can utilize, and it's initialized as an empty list by default. Tools can be added or modified post-agent initialization to adapt to new requirements.</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"how-to/Customizing-Agents/#example-assigning-tools-to-an-agent","title":"Example: Assigning Tools to an Agent","text":"<pre><code>import os\nfrom crewai import Agent\nfrom crewai_tools import SerperDevTool\n\n# Set API keys for tool initialization\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\"\n\n# Initialize a search tool\nsearch_tool = SerperDevTool()\n\n# Initialize the agent with advanced options\nagent = Agent(\n  role='Research Analyst',\n  goal='Provide up-to-date market analysis',\n  backstory='An expert analyst with a keen eye for market trends.',\n  tools=[search_tool],\n  memory=True, # Enable memory\n  verbose=True,\n  max_rpm=None, # No limit on requests per minute\n  max_iter=15, # Default value for maximum iterations\n  allow_delegation=False\n)\n</code></pre>"},{"location":"how-to/Customizing-Agents/#delegation-and-autonomy","title":"Delegation and Autonomy","text":"<p>Controlling an agent's ability to delegate tasks or ask questions is vital for tailoring its autonomy and collaborative dynamics within the CrewAI framework. By default, the <code>allow_delegation</code> attribute is set to <code>True</code>, enabling agents to seek assistance or delegate tasks as needed. This default behavior promotes collaborative problem-solving and efficiency within the CrewAI ecosystem. If needed, delegation can be disabled to suit specific operational requirements.</p>"},{"location":"how-to/Customizing-Agents/#example-disabling-delegation-for-an-agent","title":"Example: Disabling Delegation for an Agent","text":"<pre><code>agent = Agent(\n  role='Content Writer',\n  goal='Write engaging content on market trends',\n  backstory='A seasoned writer with expertise in market analysis.',\n  allow_delegation=False # Disabling delegation\n)\n</code></pre>"},{"location":"how-to/Customizing-Agents/#conclusion","title":"Conclusion","text":"<p>Customizing agents in CrewAI by setting their roles, goals, backstories, and tools, alongside advanced options like language model customization, memory, performance settings, and delegation preferences, equips a nuanced and capable AI team ready for complex challenges.</p>"},{"location":"how-to/Hierarchical/","title":"Implementing the Hierarchical Process in CrewAI","text":""},{"location":"how-to/Hierarchical/#introduction","title":"Introduction","text":"<p>The hierarchical process in CrewAI introduces a structured approach to task management, simulating traditional organizational hierarchies for efficient task delegation and execution. This systematic workflow enhances project outcomes by ensuring tasks are handled with optimal efficiency and accuracy.</p> <p>Complexity and Efficiency</p> <p>The hierarchical process is designed to leverage advanced models like GPT-4, optimizing token usage while handling complex tasks with greater efficiency.</p>"},{"location":"how-to/Hierarchical/#hierarchical-process-overview","title":"Hierarchical Process Overview","text":"<p>By default, tasks in CrewAI are managed through a sequential process. However, adopting a hierarchical approach allows for a clear hierarchy in task management, where a 'manager' agent coordinates the workflow, delegates tasks, and validates outcomes for streamlined and effective execution. This manager agent is automatically created by crewAI so you don't need to worry about it.</p>"},{"location":"how-to/Hierarchical/#key-features","title":"Key Features","text":"<ul> <li>Task Delegation: A manager agent allocates tasks among crew members based on their roles and capabilities.</li> <li>Result Validation: The manager evaluates outcomes to ensure they meet the required standards.</li> <li>Efficient Workflow: Emulates corporate structures, providing an organized approach to task management.</li> </ul>"},{"location":"how-to/Hierarchical/#implementing-the-hierarchical-process","title":"Implementing the Hierarchical Process","text":"<p>To utilize the hierarchical process, it's essential to explicitly set the process attribute to <code>Process.hierarchical</code>, as the default behavior is <code>Process.sequential</code>. Define a crew with a designated manager and establish a clear chain of command.</p> <p>Tools and Agent Assignment</p> <p>Assign tools at the agent level to facilitate task delegation and execution by the designated agents under the manager's guidance. Tools can also be specified at the task level for precise control over tool availability during task execution.</p> <p>Manager LLM Requirement</p> <p>Configuring the <code>manager_llm</code> parameter is crucial for the hierarchical process. The system requires a manager LLM to be set up for proper function, ensuring tailored decision-making.</p> <pre><code>from langchain_openai import ChatOpenAI\nfrom crewai import Crew, Process, Agent\n\n# Agents are defined with attributes for backstory, cache, and verbose mode\nresearcher = Agent(\n    role='Researcher',\n    goal='Conduct in-depth analysis',\n    backstory='Experienced data analyst with a knack for uncovering hidden trends.',\n    cache=True,\n    verbose=False,\n    # tools=[]  # This can be optionally specified; defaults to an empty list\n)\nwriter = Agent(\n    role='Writer',\n    goal='Create engaging content',\n    backstory='Creative writer passionate about storytelling in technical domains.',\n    cache=True,\n    verbose=False,\n    # tools=[]  # Optionally specify tools; defaults to an empty list\n)\n\n# Establishing the crew with a hierarchical process and additional configurations\nproject_crew = Crew(\n    tasks=[...],  # Tasks to be delegated and executed under the manager's supervision\n    agents=[researcher, writer],\n    manager_llm=ChatOpenAI(temperature=0, model=\"gpt-4\"),  # Mandatory for hierarchical process\n    process=Process.hierarchical,  # Specifies the hierarchical management approach\n    memory=True,  # Enable memory usage for enhanced task execution\n)\n</code></pre>"},{"location":"how-to/Hierarchical/#workflow-in-action","title":"Workflow in Action","text":"<ol> <li>Task Assignment: The manager assigns tasks strategically, considering each agent's capabilities and available tools.</li> <li>Execution and Review: Agents complete their tasks with the option for asynchronous execution and callback functions for streamlined workflows.</li> <li>Sequential Task Progression: Despite being a hierarchical process, tasks follow a logical order for smooth progression, facilitated by the manager's oversight.</li> </ol>"},{"location":"how-to/Hierarchical/#conclusion","title":"Conclusion","text":"<p>Adopting the hierarchical process in crewAI, with the correct configurations and understanding of the system's capabilities, facilitates an organized and efficient approach to project management.</p>"},{"location":"how-to/Human-Input-on-Execution/","title":"Human Input in Agent Execution","text":"<p>Human input is critical in several agent execution scenarios, allowing agents to request additional information or clarification when necessary. This feature is especially useful in complex decision-making processes or when agents require more details to complete a task effectively.</p>"},{"location":"how-to/Human-Input-on-Execution/#using-human-input-with-crewai","title":"Using Human Input with CrewAI","text":"<p>To integrate human input into agent execution, set the <code>human_input</code> flag in the task definition. When enabled, the agent prompts the user for input before delivering its final answer. This input can provide extra context, clarify ambiguities, or validate the agent's output.</p>"},{"location":"how-to/Human-Input-on-Execution/#example","title":"Example:","text":"<pre><code>pip install crewai\n</code></pre> <pre><code>import os\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import SerperDevTool\n\nos.environ[\"SERPER_API_KEY\"] = \"Your Key\" # serper.dev API key\nos.environ[\"OPENAI_API_KEY\"] = \"Your Key\"\n\n# Loading Tools\nsearch_tool = SerperDevTool()\n\n# Define your agents with roles, goals, tools, and additional attributes\nresearcher = Agent(\n  role='Senior Research Analyst',\n  goal='Uncover cutting-edge developments in AI and data science',\n  backstory=(\n    \"You are a Senior Research Analyst at a leading tech think tank.\"\n    \"Your expertise lies in identifying emerging trends and technologies in AI and data science.\"\n    \"You have a knack for dissecting complex data and presenting actionable insights.\"\n  ),\n  verbose=True,\n  allow_delegation=False,\n  tools=[search_tool],\n  max_rpm=100\n)\nwriter = Agent(\n  role='Tech Content Strategist',\n  goal='Craft compelling content on tech advancements',\n  backstory=(\n    \"You are a renowned Tech Content Strategist, known for your insightful and engaging articles on technology and innovation.\"\n    \"With a deep understanding of the tech industry, you transform complex concepts into compelling narratives.\"\n  ),\n  verbose=True,\n  allow_delegation=True,\n  tools=[search_tool],\n  cache=False, # Disable cache for this agent\n)\n\n# Create tasks for your agents\ntask1 = Task(\n  description=(\n    \"Conduct a comprehensive analysis of the latest advancements in AI in 2024.\"\n    \"Identify key trends, breakthrough technologies, and potential industry impacts.\"\n    \"Compile your findings in a detailed report.\"\n    \"Make sure to check with a human if the draft is good before finalizing your answer.\"\n  ),\n  expected_output='A comprehensive full report on the latest AI advancements in 2024, leave nothing out',\n  agent=researcher,\n  human_input=True,\n)\n\ntask2 = Task(\n  description=(\n    \"Using the insights from the researcher's report, develop an engaging blog post that highlights the most significant AI advancements.\"\n    \"Your post should be informative yet accessible, catering to a tech-savvy audience.\"\n    \"Aim for a narrative that captures the essence of these breakthroughs and their implications for the future.\"\n  ),\n  expected_output='A compelling 3 paragraphs blog post formatted as markdown about the latest AI advancements in 2024',\n  agent=writer\n)\n\n# Instantiate your crew with a sequential process\ncrew = Crew(\n  agents=[researcher, writer],\n  tasks=[task1, task2],\n  verbose=2\n)\n\n# Get your crew to work!\nresult = crew.kickoff()\n\nprint(\"######################\")\nprint(result)\n</code></pre>"},{"location":"how-to/Installing-CrewAI/","title":"Installing crewAI","text":"<p>Welcome to crewAI! This guide will walk you through the installation process for crewAI and its dependencies. crewAI is a flexible and powerful AI framework that enables you to create and manage AI agents, tools, and tasks efficiently. Let's get started!</p>"},{"location":"how-to/Installing-CrewAI/#installation","title":"Installation","text":"<p>To install crewAI, you need to have Python &gt;=3.10 and &lt;=3.13 installed on your system:</p> <pre><code># Install the mains crewAI package\npip install crewai\n\n# Install the main crewAI package and the tools package\n# that includes a series of helpful tools for your agents\npip install 'crewai[tools]'\n</code></pre>"},{"location":"how-to/LLM-Connections/","title":"Connect CrewAI to LLMs","text":""},{"location":"how-to/LLM-Connections/#connect-crewai-to-llms","title":"Connect CrewAI to LLMs","text":"<p>Default LLM</p> <p>By default, CrewAI uses OpenAI's GPT-4 model for language processing. You can configure your agents to use a different model or API. This guide shows how to connect your agents to various LLMs through environment variables and direct instantiation.</p> <p>CrewAI offers flexibility in connecting to various LLMs, including local models via Ollama and different APIs like Azure. It's compatible with all LangChain LLM components, enabling diverse integrations for tailored AI solutions.</p>"},{"location":"how-to/LLM-Connections/#crewai-agent-overview","title":"CrewAI Agent Overview","text":"<p>The <code>Agent</code> class is the cornerstone for implementing AI solutions in CrewAI. Here's an updated overview reflecting the latest codebase changes:</p> <ul> <li>Attributes:<ul> <li><code>role</code>: Defines the agent's role within the solution.</li> <li><code>goal</code>: Specifies the agent's objective.</li> <li><code>backstory</code>: Provides a background story to the agent.</li> <li><code>llm</code>: Indicates the Large Language Model the agent uses. By default, it uses the GPT-4 model defined in the environment variable \"OPENAI_MODEL_NAME\".</li> <li><code>function_calling_llm</code> Optional: Will turn the ReAct crewAI agent into a function calling agent.</li> <li><code>max_iter</code>: Maximum number of iterations for an agent to execute a task, default is 15.</li> <li><code>memory</code>: Enables the agent to retain information during and a across executions. Default is <code>False</code>.</li> <li><code>max_rpm</code>: Maximum number of requests per minute the agent's execution should respect. Optional.</li> <li><code>verbose</code>: Enables detailed logging of the agent's execution. Default is <code>False</code>.</li> <li><code>allow_delegation</code>: Allows the agent to delegate tasks to other agents, default is <code>True</code>.</li> <li><code>tools</code>: Specifies the tools available to the agent for task execution. Optional.</li> <li><code>step_callback</code>: Provides a callback function to be executed after each step. Optional.</li> <li><code>cache</code>: Determines whether the agent should use a cache for tool usage. Default is <code>True</code>.</li> </ul> </li> </ul> <pre><code># Required\nos.environ[\"OPENAI_MODEL_NAME\"]=\"gpt-4-0125-preview\"\n\n# Agent will automatically use the model defined in the environment variable\nexample_agent = Agent(\n  role='Local Expert',\n  goal='Provide insights about the city',\n  backstory=\"A knowledgeable local guide.\",\n  verbose=True,\n  memory=True\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#ollama-integration","title":"Ollama Integration","text":"<p>Ollama is preferred for local LLM integration, offering customization and privacy benefits. To integrate Ollama with CrewAI, set the appropriate environment variables as shown below. </p>"},{"location":"how-to/LLM-Connections/#setting-up-ollama","title":"Setting Up Ollama","text":"<ul> <li>Environment Variables Configuration: To integrate Ollama, set the following environment variables: <pre><code>OPENAI_API_BASE='http://localhost:11434/v1'\nOPENAI_MODEL_NAME='openhermes'  # Adjust based on available model\nOPENAI_API_KEY=''\n</code></pre></li> </ul>"},{"location":"how-to/LLM-Connections/#ollama-integration-ex-for-using-llama-2-locally","title":"Ollama Integration (ex. for using Llama 2 locally)","text":"<ol> <li>Download Ollama.   </li> <li>After setting up the Ollama, Pull the Llama2 by typing following lines into the terminal <code>ollama pull llama2</code>.   </li> <li>Create a ModelFile similar the one below in your project directory. <pre><code>FROM llama2\n\n# Set parameters\n\nPARAMETER temperature 0.8\nPARAMETER stop Result\n\n# Sets a custom system message to specify the behavior of the chat assistant\n\n# Leaving it blank for now.\n\nSYSTEM \"\"\"\"\"\"\n</code></pre></li> <li>Create a script to get the base model, which in our case is llama2, and create a model on top of that with ModelFile above. PS: this will be \".sh\" file.    <pre><code>#!/bin/zsh\n\n# variables\nmodel_name=\"llama2\"\ncustom_model_name=\"crewai-llama2\"\n\n#get the base model\nollama pull $model_name\n\n#create the model file\nollama create $custom_model_name -f ./Llama2ModelFile\n</code></pre></li> <li>Go into the directory where the script file and ModelFile is located and run the script.   </li> <li>Enjoy your free Llama2 model that powered up by excellent agents from crewai.  <pre><code>from crewai import Agent, Task, Crew\nfrom langchain_openai import ChatOpenAI\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"NA\"\n\nllm = ChatOpenAI(\n    model = \"crewai-llama2\",\n    base_url = \"http://localhost:11434/v1\")\n\ngeneral_agent = Agent(role = \"Math Professor\",\n                      goal = \"\"\"Provide the solution to the students that are asking mathematical questions and give them the answer.\"\"\",\n                      backstory = \"\"\"You are an excellent math professor that likes to solve math questions in a way that everyone can understand your solution\"\"\",\n                      allow_delegation = False,\n                      verbose = True,\n                      llm = llm)\ntask = Task (description=\"\"\"what is 3 + 5\"\"\",\n             agent = general_agent,\n             expected_output=\"A numerical answer.\")\n\ncrew = Crew(\n            agents=[general_agent],\n            tasks=[task],\n            verbose=2\n        )\n\nresult = crew.kickoff()\n\nprint(result)\n</code></pre></li> </ol>"},{"location":"how-to/LLM-Connections/#huggingface-integration","title":"HuggingFace Integration","text":"<p>There are a couple of different ways you can use HuggingFace to host your LLM.</p>"},{"location":"how-to/LLM-Connections/#your-own-huggingface-endpoint","title":"Your own HuggingFace endpoint","text":"<pre><code>from langchain_community.llms import HuggingFaceEndpoint\n\nllm = HuggingFaceEndpoint(\n    endpoint_url=\"&lt;YOUR_ENDPOINT_URL_HERE&gt;\",\n    huggingfacehub_api_token=\"&lt;HF_TOKEN_HERE&gt;\",\n    task=\"text-generation\",\n    max_new_tokens=512\n)\n\nagent = Agent(\n    role=\"HuggingFace Agent\",\n    goal=\"Generate text using HuggingFace\",\n    backstory=\"A diligent explorer of GitHub docs.\",\n    llm=llm\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#from-huggingfacehub-endpoint","title":"From HuggingFaceHub endpoint","text":"<pre><code>from langchain_community.llms import HuggingFaceHub\n\nllm = HuggingFaceHub(\n    repo_id=\"HuggingFaceH4/zephyr-7b-beta\",\n    huggingfacehub_api_token=\"&lt;HF_TOKEN_HERE&gt;\",\n    task=\"text-generation\",\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#openai-compatible-api-endpoints","title":"OpenAI Compatible API Endpoints","text":"<p>Switch between APIs and models seamlessly using environment variables, supporting platforms like FastChat, LM Studio, and Mistral AI.</p>"},{"location":"how-to/LLM-Connections/#configuration-examples","title":"Configuration Examples","text":""},{"location":"how-to/LLM-Connections/#fastchat","title":"FastChat","text":"<pre><code>OPENAI_API_BASE=\"http://localhost:8001/v1\"\nOPENAI_MODEL_NAME='oh-2.5m7b-q51'\nOPENAI_API_KEY=NA\n</code></pre>"},{"location":"how-to/LLM-Connections/#lm-studio","title":"LM Studio","text":"<p>Launch LM Studio and go to the Server tab. Then select a model from the dropdown menu then wait for it to load. Once it's loaded, click the green Start Server button and use the URL, port, and API key that's shown (you can modify them). Below is an example of the default settings as of LM Studio 0.2.19: <pre><code>OPENAI_API_BASE=\"http://localhost:1234/v1\"\nOPENAI_API_KEY=\"lm-studio\"\n</code></pre></p>"},{"location":"how-to/LLM-Connections/#mistral-api","title":"Mistral API","text":"<pre><code>OPENAI_API_KEY=your-mistral-api-key\nOPENAI_API_BASE=https://api.mistral.ai/v1\nOPENAI_MODEL_NAME=\"mistral-small\"\n</code></pre>"},{"location":"how-to/LLM-Connections/#solar","title":"Solar","text":"<pre><code>from langchain_community.chat_models.solar import SolarChat\n# Initialize language model\nos.environ[\"SOLAR_API_KEY\"] = \"your-solar-api-key\"\nllm = SolarChat(max_tokens=1024)\n\nFree developer API key available here: https://console.upstage.ai/services/solar\nLangchain Example: https://github.com/langchain-ai/langchain/pull/18556\n</code></pre>"},{"location":"how-to/LLM-Connections/#text-gen-web-ui","title":"text-gen-web-ui","text":"<pre><code>OPENAI_API_BASE=http://localhost:5000/v1\nOPENAI_MODEL_NAME=NA\nOPENAI_API_KEY=NA\n</code></pre>"},{"location":"how-to/LLM-Connections/#cohere","title":"Cohere","text":"<pre><code>from langchain_cohere import ChatCohere\n# Initialize language model\nos.environ[\"COHERE_API_KEY\"] = \"your-cohere-api-key\"\nllm = ChatCohere()\n\nFree developer API key available here: https://cohere.com/\nLangchain Documentation: https://python.langchain.com/docs/integrations/chat/cohere\n</code></pre>"},{"location":"how-to/LLM-Connections/#azure-open-ai-configuration","title":"Azure Open AI Configuration","text":"<p>For Azure OpenAI API integration, set the following environment variables: <pre><code>AZURE_OPENAI_VERSION=\"2022-12-01\"\nAZURE_OPENAI_DEPLOYMENT=\"\"\nAZURE_OPENAI_ENDPOINT=\"\"\nAZURE_OPENAI_KEY=\"\"\n</code></pre></p>"},{"location":"how-to/LLM-Connections/#example-agent-with-azure-llm","title":"Example Agent with Azure LLM","text":"<pre><code>from dotenv import load_dotenv\nfrom crewai import Agent\nfrom langchain_openai import AzureChatOpenAI\n\nload_dotenv()\n\nazure_llm = AzureChatOpenAI(\n    azure_endpoint=os.environ.get(\"AZURE_OPENAI_ENDPOINT\"),\n    api_key=os.environ.get(\"AZURE_OPENAI_KEY\")\n)\n\nazure_agent = Agent(\n  role='Example Agent',\n  goal='Demonstrate custom LLM configuration',\n  backstory='A diligent explorer of GitHub docs.',\n  llm=azure_llm\n)\n</code></pre>"},{"location":"how-to/LLM-Connections/#conclusion","title":"Conclusion","text":"<p>Integrating CrewAI with different LLMs expands the framework's versatility, allowing for customized, efficient AI solutions across various domains and platforms.</p>"},{"location":"how-to/Langtrace-Observability/","title":"Langtrace Overview","text":"<p>Langtrace is an open-source tool that helps you set up observability and evaluations for LLMs, LLM frameworks and VectorDB. With Langtrace, you can get deep visibility into the cost, latency and performance of your CrewAI Agents. Additionally, you can log the hyperparameters and monitor for any performance regressions and set up a process to continuously improve your Agents. </p>"},{"location":"how-to/Langtrace-Observability/#setup-instructions","title":"Setup Instructions","text":"<ol> <li>Sign up for Langtrace by going to https://langtrace.ai/signup. </li> <li>Create a project and generate an API key. </li> <li>Install Langtrace in your code using the following commands. Note: For detailed instructions on integrating Langtrace, you can check out the official docs from here.</li> </ol> <pre><code># Install the SDK\npip install langtrace-python-sdk\n\n# Import it into your project\nfrom langtrace_python_sdk import langtrace # Must precede any llm module imports\nlangtrace.init(api_key = '&lt;LANGTRACE_API_KEY&gt;')\n</code></pre>"},{"location":"how-to/Langtrace-Observability/#features","title":"Features","text":"<ul> <li>LLM Token and Cost tracking</li> <li>Trace graph showing detailed execution steps with latency and logs</li> <li>Dataset curation using manual annotation</li> <li>Prompt versioning and management</li> <li>Prompt Playground with comparison views between models</li> <li>Testing and Evaluations</li> </ul>"},{"location":"how-to/Langtrace-Observability/#extra-links","title":"Extra links","text":"<p>\ud83d\udc26 Twitter \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udce2 Discord \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udd87 Website \u00a0\u00a0\u2022\u00a0\u00a0 \ud83d\udcd9 Documentation</p>"},{"location":"how-to/Sequential/","title":"Using the Sequential Processes in crewAI","text":""},{"location":"how-to/Sequential/#introduction","title":"Introduction","text":"<p>CrewAI offers a flexible framework for executing tasks in a structured manner, supporting both sequential and hierarchical processes. This guide outlines how to effectively implement these processes to ensure efficient task execution and project completion.</p>"},{"location":"how-to/Sequential/#sequential-process-overview","title":"Sequential Process Overview","text":"<p>The sequential process ensures tasks are executed one after the other, following a linear progression. This approach is ideal for projects requiring tasks to be completed in a specific order.</p>"},{"location":"how-to/Sequential/#key-features","title":"Key Features","text":"<ul> <li>Linear Task Flow: Ensures orderly progression by handling tasks in a predetermined sequence.</li> <li>Simplicity: Best suited for projects with clear, step-by-step tasks.</li> <li>Easy Monitoring: Facilitates easy tracking of task completion and project progress.</li> </ul>"},{"location":"how-to/Sequential/#implementing-the-sequential-process","title":"Implementing the Sequential Process","text":"<p>Assemble your crew and define tasks in the order they need to be executed.</p> <pre><code>from crewai import Crew, Process, Agent, Task\n\n# Define your agents\nresearcher = Agent(\n  role='Researcher',\n  goal='Conduct foundational research',\n  backstory='An experienced researcher with a passion for uncovering insights'\n)\nanalyst = Agent(\n  role='Data Analyst',\n  goal='Analyze research findings',\n  backstory='A meticulous analyst with a knack for uncovering patterns'\n)\nwriter = Agent(\n  role='Writer',\n  goal='Draft the final report',\n  backstory='A skilled writer with a talent for crafting compelling narratives'\n)\n\n# Define the tasks in sequence\nresearch_task = Task(description='Gather relevant data...', agent=researcher)\nanalysis_task = Task(description='Analyze the data...', agent=analyst)\nwriting_task = Task(description='Compose the report...', agent=writer)\n\n# Form the crew with a sequential process\nreport_crew = Crew(\n  agents=[researcher, analyst, writer],\n  tasks=[research_task, analysis_task, writing_task],\n  process=Process.sequential\n)\n</code></pre>"},{"location":"how-to/Sequential/#workflow-in-action","title":"Workflow in Action","text":"<ol> <li>Initial Task: In a sequential process, the first agent completes their task and signals completion.</li> <li>Subsequent Tasks: Agents pick up their tasks based on the process type, with outcomes of preceding tasks or manager directives guiding their execution.</li> <li>Completion: The process concludes once the final task is executed, leading to project completion.</li> </ol>"},{"location":"how-to/Sequential/#conclusion","title":"Conclusion","text":"<p>The sequential and hierarchical processes in CrewAI offer clear, adaptable paths for task execution. They are well-suited for projects requiring logical progression and dynamic decision-making, ensuring each step is completed effectively, thereby facilitating a cohesive final product.</p>"},{"location":"telemetry/Telemetry/","title":"Telemetry","text":""},{"location":"telemetry/Telemetry/#telemetry","title":"Telemetry","text":"<p>CrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library. Our focus is on improving and developing the features, integrations, and tools most utilized by our users.</p> <p>It's pivotal to understand that NO data is collected concerning prompts, task descriptions, agents' backstories or goals, usage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables, with the exception of the conditions mentioned. When the <code>share_crew</code> feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected to provide deeper insights while respecting user privacy.</p>"},{"location":"telemetry/Telemetry/#data-collected-includes","title":"Data Collected Includes:","text":"<ul> <li>Version of CrewAI: Assessing the adoption rate of our latest version helps us understand user needs and guide our updates.</li> <li>Python Version: Identifying the Python versions our users operate with assists in prioritizing our support efforts for these versions.</li> <li>General OS Information: Details like the number of CPUs and the operating system type (macOS, Windows, Linux) enable us to focus our development on the most used operating systems and explore the potential for OS-specific features.</li> <li>Number of Agents and Tasks in a Crew: Ensures our internal testing mirrors real-world scenarios, helping us guide users towards best practices.</li> <li>Crew Process Utilization: Understanding how crews are utilized aids in directing our development focus.</li> <li>Memory and Delegation Use by Agents: Insights into how these features are used help evaluate their effectiveness and future.</li> <li>Task Execution Mode: Knowing whether tasks are executed in parallel or sequentially influences our emphasis on enhancing parallel execution capabilities.</li> <li>Language Model Utilization: Supports our goal to improve support for the most popular languages among our users.</li> <li>Roles of Agents within a Crew: Understanding the various roles agents play aids in crafting better tools, integrations, and examples.</li> <li>Tool Usage: Identifying which tools are most frequently used allows us to prioritize improvements in those areas.</li> </ul>"},{"location":"telemetry/Telemetry/#opt-in-further-telemetry-sharing","title":"Opt-In Further Telemetry Sharing","text":"<p>Users can choose to share their complete telemetry data by enabling the <code>share_crew</code> attribute to <code>True</code> in their crew configurations. This opt-in approach respects user privacy and aligns with data protection standards by ensuring users have control over their data sharing preferences. Enabling <code>share_crew</code> results in the collection of detailed crew and task execution data, including <code>goal</code>, <code>backstory</code>, <code>context</code>, and <code>output</code> of tasks. This enables a deeper insight into usage patterns while respecting the user's choice to share.</p>"},{"location":"telemetry/Telemetry/#updates-and-revisions","title":"Updates and Revisions","text":"<p>We are committed to maintaining the accuracy and transparency of our documentation. Regular reviews and updates are performed to ensure our documentation accurately reflects the latest developments of our codebase and telemetry practices. Users are encouraged to review this section for the most current information on our data collection practices and how they contribute to the improvement of CrewAI.</p>"},{"location":"tools/BrowserbaseLoadTool/","title":"BrowserbaseLoadTool","text":""},{"location":"tools/BrowserbaseLoadTool/#description","title":"Description","text":"<p>Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.</p> <p>Power your AI data retrievals with:  - Serverless Infrastructure providing reliable browsers to extract data from complex UIs  - Stealth Mode with included fingerprinting tactics and automatic captcha solving  - Session Debugger to inspect your Browser Session with networks timeline and logs  - Live Debug to quickly debug your automation</p>"},{"location":"tools/BrowserbaseLoadTool/#installation","title":"Installation","text":"<ul> <li>Get an API key and Project ID from browserbase.com and set it in environment variables (<code>BROWSERBASE_API_KEY</code>, <code>BROWSERBASE_PROJECT_ID</code>).</li> <li>Install the Browserbase SDK along with <code>crewai[tools]</code> package:</li> </ul> <pre><code>pip install browserbase 'crewai[tools]'\n</code></pre>"},{"location":"tools/BrowserbaseLoadTool/#example","title":"Example","text":"<p>Utilize the BrowserbaseLoadTool as follows to allow your agent to load websites:</p> <pre><code>from crewai_tools import BrowserbaseLoadTool\n\ntool = BrowserbaseLoadTool()\n</code></pre>"},{"location":"tools/BrowserbaseLoadTool/#arguments","title":"Arguments","text":"<ul> <li><code>api_key</code> Optional. Browserbase API key. Default is <code>BROWSERBASE_API_KEY</code> env variable.</li> <li><code>project_id</code> Optional. Browserbase Project ID. Default is <code>BROWSERBASE_PROJECT_ID</code> env variable.</li> <li><code>text_content</code> Retrieve only text content. Default is <code>False</code>.</li> <li><code>session_id</code> Optional. Provide an existing Session ID.</li> <li><code>proxy</code> Optional. Enable/Disable Proxies.\"</li> </ul>"},{"location":"tools/CSVSearchTool/","title":"CSVSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/CSVSearchTool/#description","title":"Description","text":"<p>This tool is used to perform a RAG (Retrieval-Augmented Generation) search within a CSV file's content. It allows users to semantically search for queries in the content of a specified CSV file. This feature is particularly useful for extracting information from large CSV datasets where traditional search methods might be inefficient. All tools with \"Search\" in their name, including CSVSearchTool, are RAG tools designed for searching different sources of data.</p>"},{"location":"tools/CSVSearchTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/CSVSearchTool/#example","title":"Example","text":"<pre><code>from crewai_tools import CSVSearchTool\n\n# Initialize the tool with a specific CSV file. This setup allows the agent to only search the given CSV file.\ntool = CSVSearchTool(csv='path/to/your/csvfile.csv')\n\n# OR\n\n# Initialize the tool without a specific CSV file. Agent  will need to provide the CSV path at runtime.\ntool = CSVSearchTool()\n</code></pre>"},{"location":"tools/CSVSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>csv</code> : The path to the CSV file you want to search. This is a mandatory argument if the tool was initialized without a specific CSV file; otherwise, it is optional.</li> </ul>"},{"location":"tools/CSVSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = CSVSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/CodeDocsSearchTool/","title":"CodeDocsSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/CodeDocsSearchTool/#description","title":"Description","text":"<p>The CodeDocsSearchTool is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation. It enables users to efficiently find specific information or topics within code documentation. By providing a <code>docs_url</code> during initialization, the tool narrows down the search to that particular documentation site. Alternatively, without a specific <code>docs_url</code>, it searches across a wide array of code documentation known or discovered throughout its execution, making it versatile for various documentation search needs.</p>"},{"location":"tools/CodeDocsSearchTool/#installation","title":"Installation","text":"<p>To start using the CodeDocsSearchTool, first, install the crewai_tools package via pip:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/CodeDocsSearchTool/#example","title":"Example","text":"<p>Utilize the CodeDocsSearchTool as follows to conduct searches within code documentation:</p> <p><pre><code>from crewai_tools import CodeDocsSearchTool\n\n# To search any code documentation content if the URL is known or discovered during its execution:\ntool = CodeDocsSearchTool()\n\n# OR\n\n# To specifically focus your search on a given documentation site by providing its URL:\ntool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')\n</code></pre> Note: Substitute 'https://docs.example.com/reference' with your target documentation URL and 'How to use search tool' with the search query relevant to your needs.</p>"},{"location":"tools/CodeDocsSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>docs_url</code>: Optional. Specifies the URL of the code documentation to be searched. Providing this during the tool's initialization focuses the search on the specified documentation content.</li> </ul>"},{"location":"tools/CodeDocsSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = CodeDocsSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/DOCXSearchTool/","title":"DOCXSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/DOCXSearchTool/#description","title":"Description","text":"<p>The DOCXSearchTool is a RAG tool designed for semantic searching within DOCX documents. It enables users to effectively search and extract relevant information from DOCX files using query-based searches. This tool is invaluable for data analysis, information management, and research tasks, streamlining the process of finding specific information within large document collections.</p>"},{"location":"tools/DOCXSearchTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package by running the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/DOCXSearchTool/#example","title":"Example","text":"<p>The following example demonstrates initializing the DOCXSearchTool to search within any DOCX file's content or with a specific DOCX file path.</p> <pre><code>from crewai_tools import DOCXSearchTool\n\n# Initialize the tool to search within any DOCX file's content\ntool = DOCXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific DOCX file, so the agent can only search the content of the specified DOCX file\ntool = DOCXSearchTool(docx='path/to/your/document.docx')\n</code></pre>"},{"location":"tools/DOCXSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>docx</code>: An optional file path to a specific DOCX document you wish to search. If not provided during initialization, the tool allows for later specification of any DOCX file's content path for searching.</li> </ul>"},{"location":"tools/DOCXSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = DOCXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/DirectoryReadTool/","title":"Directory Read","text":"<pre><code># DirectoryReadTool\n\n!!! note \"Experimental\"\n    We are still working on improving tools, so there might be unexpected behavior or changes in the future.\n\n## Description\nThe DirectoryReadTool is a powerful utility designed to provide a comprehensive listing of directory contents. It can recursively navigate through the specified directory, offering users a detailed enumeration of all files, including those within subdirectories. This tool is crucial for tasks that require a thorough inventory of directory structures or for validating the organization of files within directories.\n\n## Installation\nTo utilize the DirectoryReadTool in your project, install the `crewai_tools` package. If this package is not yet part of your environment, you can install it using pip with the command below:\n\n```shell\npip install 'crewai[tools]'\n</code></pre> <p>This command installs the latest version of the <code>crewai_tools</code> package, granting access to the DirectoryReadTool among other utilities.</p>"},{"location":"tools/DirectoryReadTool/#example","title":"Example","text":"<p>Employing the DirectoryReadTool is straightforward. The following code snippet demonstrates how to set it up and use the tool to list the contents of a specified directory:</p> <pre><code>from crewai_tools import DirectoryReadTool\n\n# Initialize the tool so the agent can read any directory's content it learns about during execution\ntool = DirectoryReadTool()\n\n# OR\n\n# Initialize the tool with a specific directory, so the agent can only read the content of the specified directory\ntool = DirectoryReadTool(directory='/path/to/your/directory')\n</code></pre>"},{"location":"tools/DirectoryReadTool/#arguments","title":"Arguments","text":"<p>The DirectoryReadTool requires minimal configuration for use. The essential argument for this tool is as follows:</p> <ul> <li><code>directory</code>: Optional. An argument that specifies the path to the directory whose contents you wish to list. It accepts both absolute and relative paths, guiding the tool to the desired directory for content listing.</li> </ul>"},{"location":"tools/DirectorySearchTool/","title":"DirectorySearchTool","text":"<p>Experimental</p> <p>The DirectorySearchTool is under continuous development. Features and functionalities might evolve, and unexpected behavior may occur as we refine the tool.</p>"},{"location":"tools/DirectorySearchTool/#description","title":"Description","text":"<p>The DirectorySearchTool enables semantic search within the content of specified directories, leveraging the Retrieval-Augmented Generation (RAG) methodology for efficient navigation through files. Designed for flexibility, it allows users to dynamically specify search directories at runtime or set a fixed directory during initial setup.</p>"},{"location":"tools/DirectorySearchTool/#installation","title":"Installation","text":"<p>To use the DirectorySearchTool, begin by installing the crewai_tools package. Execute the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/DirectorySearchTool/#initialization-and-usage","title":"Initialization and Usage","text":"<p>Import the DirectorySearchTool from the <code>crewai_tools</code> package to start. You can initialize the tool without specifying a directory, enabling the setting of the search directory at runtime. Alternatively, the tool can be initialized with a predefined directory.</p> <pre><code>from crewai_tools import DirectorySearchTool\n\n# For dynamic directory specification at runtime\ntool = DirectorySearchTool()\n\n# For fixed directory searches\ntool = DirectorySearchTool(directory='/path/to/directory')\n</code></pre>"},{"location":"tools/DirectorySearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>directory</code>: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.</li> </ul>"},{"location":"tools/DirectorySearchTool/#custom-model-and-embeddings","title":"Custom Model and Embeddings","text":"<p>The DirectorySearchTool uses OpenAI for embeddings and summarization by default. Customization options for these settings include changing the model provider and configuration, enhancing flexibility for advanced users.</p> <pre><code>tool = DirectorySearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include ollama, google, anthropic, llama2, and more\n            config=dict(\n                model=\"llama2\",\n                # Additional configurations here\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/FileReadTool/","title":"FileReadTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/FileReadTool/#description","title":"Description","text":"<p>The FileReadTool conceptually represents a suite of functionalities within the crewai_tools package aimed at facilitating file reading and content retrieval. This suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics. It supports a variety of text-based file formats such as <code>.txt</code>, <code>.csv</code>, <code>.json</code>, and more. Depending on the file type, the suite offers specialized functionality, such as converting JSON content into a Python dictionary for ease of use.</p>"},{"location":"tools/FileReadTool/#installation","title":"Installation","text":"<p>To utilize the functionalities previously attributed to the FileReadTool, install the crewai_tools package:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/FileReadTool/#usage-example","title":"Usage Example","text":"<p>To get started with the FileReadTool:</p> <pre><code>from crewai_tools import FileReadTool\n\n# Initialize the tool to read any files the agents knows or lean the path for\nfile_read_tool = FileReadTool()\n\n# OR\n\n# Initialize the tool with a specific file path, so the agent can only read the content of the specified file\nfile_read_tool = FileReadTool(file_path='path/to/your/file.txt')\n</code></pre>"},{"location":"tools/FileReadTool/#arguments","title":"Arguments","text":"<ul> <li><code>file_path</code>: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.</li> </ul>"},{"location":"tools/GitHubSearchTool/","title":"GithubSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/GitHubSearchTool/#description","title":"Description","text":"<p>The GithubSearchTool is a Read, Append, and Generate (RAG) tool specifically designed for conducting semantic searches within GitHub repositories. Utilizing advanced semantic search capabilities, it sifts through code, pull requests, issues, and repositories, making it an essential tool for developers, researchers, or anyone in need of precise information from GitHub.</p>"},{"location":"tools/GitHubSearchTool/#installation","title":"Installation","text":"<p>To use the GithubSearchTool, first ensure the crewai_tools package is installed in your Python environment:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>This command installs the necessary package to run the GithubSearchTool along with any other tools included in the crewai_tools package.</p>"},{"location":"tools/GitHubSearchTool/#example","title":"Example","text":"<p>Here\u2019s how you can use the GithubSearchTool to perform semantic searches within a GitHub repository: <pre><code>from crewai_tools import GithubSearchTool\n\n# Initialize the tool for semantic searches within a specific GitHub repository\ntool = GithubSearchTool(\n    github_repo='https://github.com/example/repo',\n    content_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n\n# OR\n\n# Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution\ntool = GithubSearchTool(\n    content_types=['code', 'issue'] # Options: code, repo, pr, issue\n)\n</code></pre></p>"},{"location":"tools/GitHubSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>github_repo</code> : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search.</li> <li><code>content_types</code> : Specifies the types of content to include in your search. You must provide a list of content types from the following options: <code>code</code> for searching within the code, <code>repo</code> for searching within the repository's general information, <code>pr</code> for searching within pull requests, and <code>issue</code> for searching within issues. This field is mandatory and allows tailoring the search to specific content types within the GitHub repository.</li> </ul>"},{"location":"tools/GitHubSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = GithubSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/JSONSearchTool/","title":"JSONSearchTool","text":"<p>Experimental Status</p> <p>The JSONSearchTool is currently in an experimental phase. This means the tool is under active development, and users might encounter unexpected behavior or changes. We highly encourage feedback on any issues or suggestions for improvements.</p>"},{"location":"tools/JSONSearchTool/#description","title":"Description","text":"<p>The JSONSearchTool is designed to facilitate efficient and precise searches within JSON file contents. It utilizes a RAG (Retrieve and Generate) search mechanism, allowing users to specify a JSON path for targeted searches within a particular JSON file. This capability significantly improves the accuracy and relevance of search results.</p>"},{"location":"tools/JSONSearchTool/#installation","title":"Installation","text":"<p>To install the JSONSearchTool, use the following pip command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/JSONSearchTool/#usage-examples","title":"Usage Examples","text":"<p>Here are updated examples on how to utilize the JSONSearchTool effectively for searching within JSON files. These examples take into account the current implementation and usage patterns identified in the codebase.</p> <pre><code>from crewai.json_tools import JSONSearchTool  # Updated import path\n\n# General JSON content search\n# This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.\ntool = JSONSearchTool()\n\n# Restricting search to a specific JSON file\n# Use this initialization method when you want to limit the search scope to a specific JSON file.\ntool = JSONSearchTool(json_path='./path/to/your/file.json')\n</code></pre>"},{"location":"tools/JSONSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>json_path</code> (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.</li> </ul>"},{"location":"tools/JSONSearchTool/#configuration-options","title":"Configuration Options","text":"<p>The JSONSearchTool supports extensive customization through a configuration dictionary. This allows users to select different models for embeddings and summarization based on their requirements.</p> <pre><code>tool = JSONSearchTool(\n    config={\n        \"llm\": {\n            \"provider\": \"ollama\",  # Other options include google, openai, anthropic, llama2, etc.\n            \"config\": {\n                \"model\": \"llama2\",\n                # Additional optional configurations can be specified here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            },\n        },\n        \"embedder\": {\n            \"provider\": \"google\", # or openai, ollama, ...\n            \"config\": {\n                \"model\": \"models/embedding-001\",\n                \"task_type\": \"retrieval_document\",\n                # Further customization options can be added here.\n            },\n        },\n    }\n)\n</code></pre>"},{"location":"tools/MDXSearchTool/","title":"MDXSearchTool","text":"<p>Experimental</p> <p>The MDXSearchTool is in continuous development. Features may be added or removed, and functionality could change unpredictably as we refine the tool.</p>"},{"location":"tools/MDXSearchTool/#description","title":"Description","text":"<p>The MDX Search Tool is a component of the <code>crewai_tools</code> package aimed at facilitating advanced market data extraction. This tool is invaluable for researchers and analysts seeking quick access to market insights, especially within the AI sector. It simplifies the task of acquiring, interpreting, and organizing market data by interfacing with various data sources.</p>"},{"location":"tools/MDXSearchTool/#installation","title":"Installation","text":"<p>Before using the MDX Search Tool, ensure the <code>crewai_tools</code> package is installed. If it is not, you can install it with the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/MDXSearchTool/#usage-example","title":"Usage Example","text":"<p>To use the MDX Search Tool, you must first set up the necessary environment variables. Then, integrate the tool into your crewAI project to begin your market research. Below is a basic example of how to do this:</p> <pre><code>from crewai_tools import MDXSearchTool\n\n# Initialize the tool to search any MDX content it learns about during execution\ntool = MDXSearchTool()\n\n# OR\n\n# Initialize the tool with a specific MDX file path for an exclusive search within that document\ntool = MDXSearchTool(mdx='path/to/your/document.mdx')\n</code></pre>"},{"location":"tools/MDXSearchTool/#parameters","title":"Parameters","text":"<ul> <li>mdx: Optional. Specifies the MDX file path for the search. It can be provided during initialization.</li> </ul>"},{"location":"tools/MDXSearchTool/#customization-of-model-and-embeddings","title":"Customization of Model and Embeddings","text":"<p>The tool defaults to using OpenAI for embeddings and summarization. For customization, utilize a configuration dictionary as shown below:</p> <pre><code>tool = MDXSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # Options include google, openai, anthropic, llama2, etc.\n            config=dict(\n                model=\"llama2\",\n                # Optional parameters can be included here.\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # Optional title for the embeddings can be added here.\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/PDFSearchTool/","title":"PDFSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/PDFSearchTool/#description","title":"Description","text":"<p>The PDFSearchTool is a RAG tool designed for semantic searches within PDF content. It allows for inputting a search query and a PDF document, leveraging advanced search techniques to find relevant content efficiently. This capability makes it especially useful for extracting specific information from large PDF files quickly.</p>"},{"location":"tools/PDFSearchTool/#installation","title":"Installation","text":"<p>To get started with the PDFSearchTool, first, ensure the crewai_tools package is installed with the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/PDFSearchTool/#example","title":"Example","text":"<p>Here's how to use the PDFSearchTool to search within a PDF document:</p> <pre><code>from crewai_tools import PDFSearchTool\n\n# Initialize the tool allowing for any PDF content search if the path is provided during execution\ntool = PDFSearchTool()\n\n# OR\n\n# Initialize the tool with a specific PDF path for exclusive search within that document\ntool = PDFSearchTool(pdf='path/to/your/document.pdf')\n</code></pre>"},{"location":"tools/PDFSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>pdf</code>: Optinal The PDF path for the search. Can be provided at initialization or within the <code>run</code> method's arguments. If provided at initialization, the tool confines its search to the specified document.</li> </ul>"},{"location":"tools/PDFSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = PDFSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/PGSearchTool/","title":"PGSearchTool","text":"<p>Under Development</p> <p>The PGSearchTool is currently under development. This document outlines the intended functionality and interface. As development progresses, please be aware that some features may not be available or could change.</p>"},{"location":"tools/PGSearchTool/#description","title":"Description","text":"<p>The PGSearchTool is envisioned as a powerful tool for facilitating semantic searches within PostgreSQL database tables. By leveraging advanced Retrieve and Generate (RAG) technology, it aims to provide an efficient means for querying database table content, specifically tailored for PostgreSQL databases. The tool's goal is to simplify the process of finding relevant data through semantic search queries, offering a valuable resource for users needing to conduct advanced queries on extensive datasets within a PostgreSQL environment.</p>"},{"location":"tools/PGSearchTool/#installation","title":"Installation","text":"<p>The <code>crewai_tools</code> package, which will include the PGSearchTool upon its release, can be installed using the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>(Note: The PGSearchTool is not yet available in the current version of the <code>crewai_tools</code> package. This installation command will be updated once the tool is released.)</p>"},{"location":"tools/PGSearchTool/#example-usage","title":"Example Usage","text":"<p>Below is a proposed example showcasing how to use the PGSearchTool for conducting a semantic search on a table within a PostgreSQL database:</p> <pre><code>from crewai_tools import PGSearchTool\n\n# Initialize the tool with the database URI and the target table name\ntool = PGSearchTool(db_uri='postgresql://user:password@localhost:5432/mydatabase', table_name='employees')\n</code></pre>"},{"location":"tools/PGSearchTool/#arguments","title":"Arguments","text":"<p>The PGSearchTool is designed to require the following arguments for its operation:</p> <ul> <li><code>db_uri</code>: A string representing the URI of the PostgreSQL database to be queried. This argument will be mandatory and must include the necessary authentication details and the location of the database.</li> <li><code>table_name</code>: A string specifying the name of the table within the database on which the semantic search will be performed. This argument will also be mandatory.</li> </ul>"},{"location":"tools/PGSearchTool/#custom-model-and-embeddings","title":"Custom Model and Embeddings","text":"<p>The tool intends to use OpenAI for both embeddings and summarization by default. Users will have the option to customize the model using a config dictionary as follows:</p> <pre><code>tool = PGSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/ScrapeWebsiteTool/","title":"ScrapeWebsiteTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/ScrapeWebsiteTool/#description","title":"Description","text":"<p>A tool designed to extract and read the content of a specified website. It is capable of handling various types of web pages by making HTTP requests and parsing the received HTML content. This tool can be particularly useful for web scraping tasks, data collection, or extracting specific information from websites.</p>"},{"location":"tools/ScrapeWebsiteTool/#installation","title":"Installation","text":"<p>Install the crewai_tools package <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/ScrapeWebsiteTool/#example","title":"Example","text":"<pre><code>from crewai_tools import ScrapeWebsiteTool\n\n# To enable scrapping any website it finds during it's execution\ntool = ScrapeWebsiteTool()\n\n# Initialize the tool with the website URL, so the agent can only scrap the content of the specified website\ntool = ScrapeWebsiteTool(website_url='https://www.example.com')\n\n# Extract the text from the site\ntext = tool.run()\nprint(text)\n</code></pre>"},{"location":"tools/ScrapeWebsiteTool/#arguments","title":"Arguments","text":"<ul> <li><code>website_url</code> : Mandatory website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read.</li> </ul>"},{"location":"tools/SeleniumScrapingTool/","title":"SeleniumScrapingTool","text":"<p>Experimental</p> <p>This tool is currently in development. As we refine its capabilities, users may encounter unexpected behavior. Your feedback is invaluable to us for making improvements.</p>"},{"location":"tools/SeleniumScrapingTool/#description","title":"Description","text":"<p>The SeleniumScrapingTool is crafted for high-efficiency web scraping tasks. It allows for precise extraction of content from web pages by using CSS selectors to target specific elements. Its design caters to a wide range of scraping needs, offering flexibility to work with any provided website URL.</p>"},{"location":"tools/SeleniumScrapingTool/#installation","title":"Installation","text":"<p>To get started with the SeleniumScrapingTool, install the crewai_tools package using pip:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/SeleniumScrapingTool/#usage-examples","title":"Usage Examples","text":"<p>Below are some scenarios where the SeleniumScrapingTool can be utilized:</p> <pre><code>from crewai_tools import SeleniumScrapingTool\n\n# Example 1: Initialize the tool without any parameters to scrape the current page it navigates to\ntool = SeleniumScrapingTool()\n\n# Example 2: Scrape the entire webpage of a given URL\ntool = SeleniumScrapingTool(website_url='https://example.com')\n\n# Example 3: Target and scrape a specific CSS element from a webpage\ntool = SeleniumScrapingTool(website_url='https://example.com', css_element='.main-content')\n\n# Example 4: Perform scraping with additional parameters for a customized experience\ntool = SeleniumScrapingTool(website_url='https://example.com', css_element='.main-content', cookie={'name': 'user', 'value': 'John Doe'}, wait_time=10)\n</code></pre>"},{"location":"tools/SeleniumScrapingTool/#arguments","title":"Arguments","text":"<p>The following parameters can be used to customize the SeleniumScrapingTool's scraping process:</p> <ul> <li><code>website_url</code>: Mandatory. Specifies the URL of the website from which content is to be scraped.</li> <li><code>css_element</code>: Mandatory. The CSS selector for a specific element to target on the website. This enables focused scraping of a particular part of a webpage.</li> <li><code>cookie</code>: Optional. A dictionary that contains cookie information. Useful for simulating a logged-in session, thereby providing access to content that might be restricted to non-logged-in users.</li> <li><code>wait_time</code>: Optional. Specifies the delay (in seconds) before the content is scraped. This delay allows for the website and any dynamic content to fully load, ensuring a successful scrape.</li> </ul> <p>Attention</p> <p>Since the SeleniumScrapingTool is under active development, the parameters and functionality may evolve over time. Users are encouraged to keep the tool updated and report any issues or suggestions for enhancements.</p>"},{"location":"tools/SerperDevTool/","title":"SerperDevTool Documentation","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/SerperDevTool/#description","title":"Description","text":"<p>This tool is designed to perform a semantic search for a specified query from a text's content across the internet. It utilizes the serper.dev API to fetch and display the most relevant search results based on the query provided by the user.</p>"},{"location":"tools/SerperDevTool/#installation","title":"Installation","text":"<p>To incorporate this tool into your project, follow the installation instructions below: <pre><code>pip install 'crewai[tools]'\n</code></pre></p>"},{"location":"tools/SerperDevTool/#example","title":"Example","text":"<p>The following example demonstrates how to initialize the tool and execute a search with a given query:</p> <pre><code>from crewai_tools import SerperDevTool\n\n# Initialize the tool for internet searching capabilities\ntool = SerperDevTool()\n</code></pre>"},{"location":"tools/SerperDevTool/#steps-to-get-started","title":"Steps to Get Started","text":"<p>To effectively use the <code>SerperDevTool</code>, follow these steps:</p> <ol> <li>Package Installation: Confirm that the <code>crewai[tools]</code> package is installed in your Python environment.</li> <li>API Key Acquisition: Acquire a <code>serper.dev</code> API key by registering for a free account at <code>serper.dev</code>.</li> <li>Environment Configuration: Store your obtained API key in an environment variable named <code>SERPER_API_KEY</code> to facilitate its use by the tool.</li> </ol>"},{"location":"tools/SerperDevTool/#conclusion","title":"Conclusion","text":"<p>By integrating the <code>SerperDevTool</code> into Python projects, users gain the ability to conduct real-time, relevant searches across the internet directly from their applications. By adhering to the setup and usage guidelines provided, incorporating this tool into projects is streamlined and straightforward.</p>"},{"location":"tools/TXTSearchTool/","title":"TXTSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/TXTSearchTool/#description","title":"Description","text":"<p>This tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file. It allows for semantic searching of a query within a specified text file's content, making it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.</p>"},{"location":"tools/TXTSearchTool/#installation","title":"Installation","text":"<p>To use the TXTSearchTool, you first need to install the crewai_tools package. This can be done using pip, a package manager for Python. Open your terminal or command prompt and enter the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>This command will download and install the TXTSearchTool along with any necessary dependencies.</p>"},{"location":"tools/TXTSearchTool/#example","title":"Example","text":"<p>The following example demonstrates how to use the TXTSearchTool to search within a text file. This example shows both the initialization of the tool with a specific text file and the subsequent search within that file's content.</p> <pre><code>from crewai_tools import TXTSearchTool\n\n# Initialize the tool to search within any text file's content the agent learns about during its execution\ntool = TXTSearchTool()\n\n# OR\n\n# Initialize the tool with a specific text file, so the agent can search within the given text file's content\ntool = TXTSearchTool(txt='path/to/text/file.txt')\n</code></pre>"},{"location":"tools/TXTSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>txt</code> (str): Optinal. The path to the text file you want to search. This argument is only required if the tool was not initialized with a specific text file; otherwise, the search will be conducted within the initially provided text file.</li> </ul>"},{"location":"tools/TXTSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = TXTSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/WebsiteSearchTool/","title":"WebsiteSearchTool","text":"<p>Experimental Status</p> <p>The WebsiteSearchTool is currently in an experimental phase. We are actively working on incorporating this tool into our suite of offerings and will update the documentation accordingly.</p>"},{"location":"tools/WebsiteSearchTool/#description","title":"Description","text":"<p>The WebsiteSearchTool is designed as a concept for conducting semantic searches within the content of websites. It aims to leverage advanced machine learning models like Retrieval-Augmented Generation (RAG) to navigate and extract information from specified URLs efficiently. This tool intends to offer flexibility, allowing users to perform searches across any website or focus on specific websites of interest. Please note, the current implementation details of the WebsiteSearchTool are under development, and its functionalities as described may not yet be accessible.</p>"},{"location":"tools/WebsiteSearchTool/#installation","title":"Installation","text":"<p>To prepare your environment for when the WebsiteSearchTool becomes available, you can install the foundational package with:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre> <p>This command installs the necessary dependencies to ensure that once the tool is fully integrated, users can start using it immediately.</p>"},{"location":"tools/WebsiteSearchTool/#example-usage","title":"Example Usage","text":"<p>Below are examples of how the WebsiteSearchTool could be utilized in different scenarios. Please note, these examples are illustrative and represent planned functionality:</p> <pre><code>from crewai_tools import WebsiteSearchTool\n\n# Example of initiating tool that agents can use to search across any discovered websites\ntool = WebsiteSearchTool()\n\n# Example of limiting the search to the content of a specific website, so now agents can only search within that website\ntool = WebsiteSearchTool(website='https://example.com')\n</code></pre>"},{"location":"tools/WebsiteSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>website</code>: An optional argument intended to specify the website URL for focused searches. This argument is designed to enhance the tool's flexibility by allowing targeted searches when necessary.</li> </ul>"},{"location":"tools/WebsiteSearchTool/#customization-options","title":"Customization Options","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = WebsiteSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/XMLSearchTool/","title":"XMLSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/XMLSearchTool/#description","title":"Description","text":"<p>The XMLSearchTool is a cutting-edge RAG tool engineered for conducting semantic searches within XML files. Ideal for users needing to parse and extract information from XML content efficiently, this tool supports inputting a search query and an optional XML file path. By specifying an XML path, users can target their search more precisely to the content of that file, thereby obtaining more relevant search outcomes.</p>"},{"location":"tools/XMLSearchTool/#installation","title":"Installation","text":"<p>To start using the XMLSearchTool, you must first install the crewai_tools package. This can be easily done with the following command:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/XMLSearchTool/#example","title":"Example","text":"<p>Here are two examples demonstrating how to use the XMLSearchTool. The first example shows searching within a specific XML file, while the second example illustrates initiating a search without predefining an XML path, providing flexibility in search scope.</p> <pre><code>from crewai_tools import XMLSearchTool\n\n# Allow agents to search within any XML file's content as it learns about their paths during execution\ntool = XMLSearchTool()\n\n# OR\n\n# Initialize the tool with a specific XML file path for exclusive search within that document\ntool = XMLSearchTool(xml='path/to/your/xmlfile.xml')\n</code></pre>"},{"location":"tools/XMLSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>xml</code>: This is the path to the XML file you wish to search. It is an optional parameter during the tool's initialization but must be provided either at initialization or as part of the <code>run</code> method's arguments to execute a search.</li> </ul>"},{"location":"tools/XMLSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = XMLSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/YoutubeChannelSearchTool/","title":"YoutubeChannelSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/YoutubeChannelSearchTool/#description","title":"Description","text":"<p>This tool is designed to perform semantic searches within a specific Youtube channel's content. Leveraging the RAG (Retrieval-Augmented Generation) methodology, it provides relevant search results, making it invaluable for extracting information or finding specific content without the need to manually sift through videos. It streamlines the search process within Youtube channels, catering to researchers, content creators, and viewers seeking specific information or topics.</p>"},{"location":"tools/YoutubeChannelSearchTool/#installation","title":"Installation","text":"<p>To utilize the YoutubeChannelSearchTool, the <code>crewai_tools</code> package must be installed. Execute the following command in your shell to install:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/YoutubeChannelSearchTool/#example","title":"Example","text":"<p>To begin using the YoutubeChannelSearchTool, follow the example below. This demonstrates initializing the tool with a specific Youtube channel handle and conducting a search within that channel's content.</p> <pre><code>from crewai_tools import YoutubeChannelSearchTool\n\n# Initialize the tool to search within any Youtube channel's content the agent learns about during its execution\ntool = YoutubeChannelSearchTool()\n\n# OR\n\n# Initialize the tool with a specific Youtube channel handle to target your search\ntool = YoutubeChannelSearchTool(youtube_channel_handle='@exampleChannel')\n</code></pre>"},{"location":"tools/YoutubeChannelSearchTool/#arguments","title":"Arguments","text":"<ul> <li><code>youtube_channel_handle</code> : A mandatory string representing the Youtube channel handle. This parameter is crucial for initializing the tool to specify the channel you want to search within. The tool is designed to only search within the content of the provided channel handle.</li> </ul>"},{"location":"tools/YoutubeChannelSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = YoutubeChannelSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"},{"location":"tools/YoutubeVideoSearchTool/","title":"YoutubeVideoSearchTool","text":"<p>Experimental</p> <p>We are still working on improving tools, so there might be unexpected behavior or changes in the future.</p>"},{"location":"tools/YoutubeVideoSearchTool/#description","title":"Description","text":"<p>This tool is part of the <code>crewai_tools</code> package and is designed to perform semantic searches within Youtube video content, utilizing Retrieval-Augmented Generation (RAG) techniques. It is one of several \"Search\" tools in the package that leverage RAG for different sources. The YoutubeVideoSearchTool allows for flexibility in searches; users can search across any Youtube video content without specifying a video URL, or they can target their search to a specific Youtube video by providing its URL.</p>"},{"location":"tools/YoutubeVideoSearchTool/#installation","title":"Installation","text":"<p>To utilize the YoutubeVideoSearchTool, you must first install the <code>crewai_tools</code> package. This package contains the YoutubeVideoSearchTool among other utilities designed to enhance your data analysis and processing tasks. Install the package by executing the following command in your terminal:</p> <pre><code>pip install 'crewai[tools]'\n</code></pre>"},{"location":"tools/YoutubeVideoSearchTool/#example","title":"Example","text":"<p>To integrate the YoutubeVideoSearchTool into your Python projects, follow the example below. This demonstrates how to use the tool both for general Youtube content searches and for targeted searches within a specific video's content.</p> <pre><code>from crewai_tools import YoutubeVideoSearchTool\n\n# General search across Youtube content without specifying a video URL, so the agent can search within any Youtube video content it learns about irs url during its operation\ntool = YoutubeVideoSearchTool()\n\n# Targeted search within a specific Youtube video's content\ntool = YoutubeVideoSearchTool(youtube_video_url='https://youtube.com/watch?v=example')\n</code></pre>"},{"location":"tools/YoutubeVideoSearchTool/#arguments","title":"Arguments","text":"<p>The YoutubeVideoSearchTool accepts the following initialization arguments:</p> <ul> <li><code>youtube_video_url</code>: An optional argument at initialization but required if targeting a specific Youtube video. It specifies the Youtube video URL path you want to search within.</li> </ul>"},{"location":"tools/YoutubeVideoSearchTool/#custom-model-and-embeddings","title":"Custom model and embeddings","text":"<p>By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:</p> <pre><code>tool = YoutubeVideoSearchTool(\n    config=dict(\n        llm=dict(\n            provider=\"ollama\", # or google, openai, anthropic, llama2, ...\n            config=dict(\n                model=\"llama2\",\n                # temperature=0.5,\n                # top_p=1,\n                # stream=true,\n            ),\n        ),\n        embedder=dict(\n            provider=\"google\", # or openai, ollama, ...\n            config=dict(\n                model=\"models/embedding-001\",\n                task_type=\"retrieval_document\",\n                # title=\"Embeddings\",\n            ),\n        ),\n    )\n)\n</code></pre>"}]}